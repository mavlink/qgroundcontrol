// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pixhawk.proto

#ifndef PROTOBUF_pixhawk_2eproto__INCLUDED
#define PROTOBUF_pixhawk_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace px {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pixhawk_2eproto();
void protobuf_AssignDesc_pixhawk_2eproto();
void protobuf_ShutdownFile_pixhawk_2eproto();

class PointCloudXYZI;
class PointCloudXYZI_PointXYZI;
class PointCloudXYZRGB;
class PointCloudXYZRGB_PointXYZRGB;
class RGBDImage;
class Obstacle;
class ObstacleList;
class ObstacleMap;

// ===================================================================

class PointCloudXYZI_PointXYZI : public ::google::protobuf::Message {
 public:
  PointCloudXYZI_PointXYZI();
  virtual ~PointCloudXYZI_PointXYZI();
  
  PointCloudXYZI_PointXYZI(const PointCloudXYZI_PointXYZI& from);
  
  inline PointCloudXYZI_PointXYZI& operator=(const PointCloudXYZI_PointXYZI& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloudXYZI_PointXYZI& default_instance();
  
  void Swap(PointCloudXYZI_PointXYZI* other);
  
  // implements Message ----------------------------------------------
  
  PointCloudXYZI_PointXYZI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointCloudXYZI_PointXYZI& from);
  void MergeFrom(const PointCloudXYZI_PointXYZI& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);
  
  // required float intensity = 4;
  inline bool has_intensity() const;
  inline void clear_intensity();
  static const int kIntensityFieldNumber = 4;
  inline float intensity() const;
  inline void set_intensity(float value);
  
  // @@protoc_insertion_point(class_scope:px.PointCloudXYZI.PointXYZI)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_intensity();
  inline void clear_has_intensity();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float z_;
  float intensity_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static PointCloudXYZI_PointXYZI* default_instance_;
};
// -------------------------------------------------------------------

class PointCloudXYZI : public ::google::protobuf::Message {
 public:
  PointCloudXYZI();
  virtual ~PointCloudXYZI();
  
  PointCloudXYZI(const PointCloudXYZI& from);
  
  inline PointCloudXYZI& operator=(const PointCloudXYZI& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloudXYZI& default_instance();
  
  void Swap(PointCloudXYZI* other);
  
  // implements Message ----------------------------------------------
  
  PointCloudXYZI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointCloudXYZI& from);
  void MergeFrom(const PointCloudXYZI& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef PointCloudXYZI_PointXYZI PointXYZI;
  
  // accessors -------------------------------------------------------
  
  // repeated .px.PointCloudXYZI.PointXYZI points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::px::PointCloudXYZI_PointXYZI& points(int index) const;
  inline ::px::PointCloudXYZI_PointXYZI* mutable_points(int index);
  inline ::px::PointCloudXYZI_PointXYZI* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZI_PointXYZI >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZI_PointXYZI >*
      mutable_points();
  
  // @@protoc_insertion_point(class_scope:px.PointCloudXYZI)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZI_PointXYZI > points_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static PointCloudXYZI* default_instance_;
};
// -------------------------------------------------------------------

class PointCloudXYZRGB_PointXYZRGB : public ::google::protobuf::Message {
 public:
  PointCloudXYZRGB_PointXYZRGB();
  virtual ~PointCloudXYZRGB_PointXYZRGB();
  
  PointCloudXYZRGB_PointXYZRGB(const PointCloudXYZRGB_PointXYZRGB& from);
  
  inline PointCloudXYZRGB_PointXYZRGB& operator=(const PointCloudXYZRGB_PointXYZRGB& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloudXYZRGB_PointXYZRGB& default_instance();
  
  void Swap(PointCloudXYZRGB_PointXYZRGB* other);
  
  // implements Message ----------------------------------------------
  
  PointCloudXYZRGB_PointXYZRGB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointCloudXYZRGB_PointXYZRGB& from);
  void MergeFrom(const PointCloudXYZRGB_PointXYZRGB& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);
  
  // required float rgb = 4;
  inline bool has_rgb() const;
  inline void clear_rgb();
  static const int kRgbFieldNumber = 4;
  inline float rgb() const;
  inline void set_rgb(float value);
  
  // @@protoc_insertion_point(class_scope:px.PointCloudXYZRGB.PointXYZRGB)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_rgb();
  inline void clear_has_rgb();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float z_;
  float rgb_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static PointCloudXYZRGB_PointXYZRGB* default_instance_;
};
// -------------------------------------------------------------------

class PointCloudXYZRGB : public ::google::protobuf::Message {
 public:
  PointCloudXYZRGB();
  virtual ~PointCloudXYZRGB();
  
  PointCloudXYZRGB(const PointCloudXYZRGB& from);
  
  inline PointCloudXYZRGB& operator=(const PointCloudXYZRGB& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloudXYZRGB& default_instance();
  
  void Swap(PointCloudXYZRGB* other);
  
  // implements Message ----------------------------------------------
  
  PointCloudXYZRGB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointCloudXYZRGB& from);
  void MergeFrom(const PointCloudXYZRGB& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef PointCloudXYZRGB_PointXYZRGB PointXYZRGB;
  
  // accessors -------------------------------------------------------
  
  // repeated .px.PointCloudXYZRGB.PointXYZRGB points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::px::PointCloudXYZRGB_PointXYZRGB& points(int index) const;
  inline ::px::PointCloudXYZRGB_PointXYZRGB* mutable_points(int index);
  inline ::px::PointCloudXYZRGB_PointXYZRGB* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZRGB_PointXYZRGB >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZRGB_PointXYZRGB >*
      mutable_points();
  
  // @@protoc_insertion_point(class_scope:px.PointCloudXYZRGB)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZRGB_PointXYZRGB > points_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static PointCloudXYZRGB* default_instance_;
};
// -------------------------------------------------------------------

class RGBDImage : public ::google::protobuf::Message {
 public:
  RGBDImage();
  virtual ~RGBDImage();
  
  RGBDImage(const RGBDImage& from);
  
  inline RGBDImage& operator=(const RGBDImage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RGBDImage& default_instance();
  
  void Swap(RGBDImage* other);
  
  // implements Message ----------------------------------------------
  
  RGBDImage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RGBDImage& from);
  void MergeFrom(const RGBDImage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 cols = 1;
  inline bool has_cols() const;
  inline void clear_cols();
  static const int kColsFieldNumber = 1;
  inline ::google::protobuf::uint32 cols() const;
  inline void set_cols(::google::protobuf::uint32 value);
  
  // required uint32 rows = 2;
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 2;
  inline ::google::protobuf::uint32 rows() const;
  inline void set_rows(::google::protobuf::uint32 value);
  
  // required uint32 step1 = 3;
  inline bool has_step1() const;
  inline void clear_step1();
  static const int kStep1FieldNumber = 3;
  inline ::google::protobuf::uint32 step1() const;
  inline void set_step1(::google::protobuf::uint32 value);
  
  // required uint32 type1 = 4;
  inline bool has_type1() const;
  inline void clear_type1();
  static const int kType1FieldNumber = 4;
  inline ::google::protobuf::uint32 type1() const;
  inline void set_type1(::google::protobuf::uint32 value);
  
  // required bytes imageData1 = 5;
  inline bool has_imagedata1() const;
  inline void clear_imagedata1();
  static const int kImageData1FieldNumber = 5;
  inline const ::std::string& imagedata1() const;
  inline void set_imagedata1(const ::std::string& value);
  inline void set_imagedata1(const char* value);
  inline void set_imagedata1(const void* value, size_t size);
  inline ::std::string* mutable_imagedata1();
  inline ::std::string* release_imagedata1();
  
  // required uint32 step2 = 6;
  inline bool has_step2() const;
  inline void clear_step2();
  static const int kStep2FieldNumber = 6;
  inline ::google::protobuf::uint32 step2() const;
  inline void set_step2(::google::protobuf::uint32 value);
  
  // required uint32 type2 = 7;
  inline bool has_type2() const;
  inline void clear_type2();
  static const int kType2FieldNumber = 7;
  inline ::google::protobuf::uint32 type2() const;
  inline void set_type2(::google::protobuf::uint32 value);
  
  // required bytes imageData2 = 8;
  inline bool has_imagedata2() const;
  inline void clear_imagedata2();
  static const int kImageData2FieldNumber = 8;
  inline const ::std::string& imagedata2() const;
  inline void set_imagedata2(const ::std::string& value);
  inline void set_imagedata2(const char* value);
  inline void set_imagedata2(const void* value, size_t size);
  inline ::std::string* mutable_imagedata2();
  inline ::std::string* release_imagedata2();
  
  // optional uint32 camera_config = 9;
  inline bool has_camera_config() const;
  inline void clear_camera_config();
  static const int kCameraConfigFieldNumber = 9;
  inline ::google::protobuf::uint32 camera_config() const;
  inline void set_camera_config(::google::protobuf::uint32 value);
  
  // optional uint32 camera_type = 10;
  inline bool has_camera_type() const;
  inline void clear_camera_type();
  static const int kCameraTypeFieldNumber = 10;
  inline ::google::protobuf::uint32 camera_type() const;
  inline void set_camera_type(::google::protobuf::uint32 value);
  
  // optional uint64 timestamp = 11;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 11;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);
  
  // optional float roll = 12;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 12;
  inline float roll() const;
  inline void set_roll(float value);
  
  // optional float pitch = 13;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 13;
  inline float pitch() const;
  inline void set_pitch(float value);
  
  // optional float yaw = 14;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 14;
  inline float yaw() const;
  inline void set_yaw(float value);
  
  // optional float lon = 15;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 15;
  inline float lon() const;
  inline void set_lon(float value);
  
  // optional float lat = 16;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 16;
  inline float lat() const;
  inline void set_lat(float value);
  
  // optional float alt = 17;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 17;
  inline float alt() const;
  inline void set_alt(float value);
  
  // optional float ground_x = 18;
  inline bool has_ground_x() const;
  inline void clear_ground_x();
  static const int kGroundXFieldNumber = 18;
  inline float ground_x() const;
  inline void set_ground_x(float value);
  
  // optional float ground_y = 19;
  inline bool has_ground_y() const;
  inline void clear_ground_y();
  static const int kGroundYFieldNumber = 19;
  inline float ground_y() const;
  inline void set_ground_y(float value);
  
  // optional float ground_z = 20;
  inline bool has_ground_z() const;
  inline void clear_ground_z();
  static const int kGroundZFieldNumber = 20;
  inline float ground_z() const;
  inline void set_ground_z(float value);
  
  // repeated float camera_matrix = 21;
  inline int camera_matrix_size() const;
  inline void clear_camera_matrix();
  static const int kCameraMatrixFieldNumber = 21;
  inline float camera_matrix(int index) const;
  inline void set_camera_matrix(int index, float value);
  inline void add_camera_matrix(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      camera_matrix() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_camera_matrix();
  
  // @@protoc_insertion_point(class_scope:px.RGBDImage)
 private:
  inline void set_has_cols();
  inline void clear_has_cols();
  inline void set_has_rows();
  inline void clear_has_rows();
  inline void set_has_step1();
  inline void clear_has_step1();
  inline void set_has_type1();
  inline void clear_has_type1();
  inline void set_has_imagedata1();
  inline void clear_has_imagedata1();
  inline void set_has_step2();
  inline void clear_has_step2();
  inline void set_has_type2();
  inline void clear_has_type2();
  inline void set_has_imagedata2();
  inline void clear_has_imagedata2();
  inline void set_has_camera_config();
  inline void clear_has_camera_config();
  inline void set_has_camera_type();
  inline void clear_has_camera_type();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_yaw();
  inline void clear_has_yaw();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_alt();
  inline void clear_has_alt();
  inline void set_has_ground_x();
  inline void clear_has_ground_x();
  inline void set_has_ground_y();
  inline void clear_has_ground_y();
  inline void set_has_ground_z();
  inline void clear_has_ground_z();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 cols_;
  ::google::protobuf::uint32 rows_;
  ::google::protobuf::uint32 step1_;
  ::google::protobuf::uint32 type1_;
  ::std::string* imagedata1_;
  ::google::protobuf::uint32 step2_;
  ::google::protobuf::uint32 type2_;
  ::std::string* imagedata2_;
  ::google::protobuf::uint32 camera_config_;
  ::google::protobuf::uint32 camera_type_;
  ::google::protobuf::uint64 timestamp_;
  float roll_;
  float pitch_;
  float yaw_;
  float lon_;
  float lat_;
  float alt_;
  float ground_x_;
  float ground_y_;
  ::google::protobuf::RepeatedField< float > camera_matrix_;
  float ground_z_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static RGBDImage* default_instance_;
};
// -------------------------------------------------------------------

class Obstacle : public ::google::protobuf::Message {
 public:
  Obstacle();
  virtual ~Obstacle();
  
  Obstacle(const Obstacle& from);
  
  inline Obstacle& operator=(const Obstacle& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Obstacle& default_instance();
  
  void Swap(Obstacle* other);
  
  // implements Message ----------------------------------------------
  
  Obstacle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Obstacle& from);
  void MergeFrom(const Obstacle& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);
  
  // optional float length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  inline float length() const;
  inline void set_length(float value);
  
  // optional float width = 5;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 5;
  inline float width() const;
  inline void set_width(float value);
  
  // optional float height = 6;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 6;
  inline float height() const;
  inline void set_height(float value);
  
  // @@protoc_insertion_point(class_scope:px.Obstacle)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float z_;
  float length_;
  float width_;
  float height_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static Obstacle* default_instance_;
};
// -------------------------------------------------------------------

class ObstacleList : public ::google::protobuf::Message {
 public:
  ObstacleList();
  virtual ~ObstacleList();
  
  ObstacleList(const ObstacleList& from);
  
  inline ObstacleList& operator=(const ObstacleList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleList& default_instance();
  
  void Swap(ObstacleList* other);
  
  // implements Message ----------------------------------------------
  
  ObstacleList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObstacleList& from);
  void MergeFrom(const ObstacleList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint64 utime = 1;
  inline bool has_utime() const;
  inline void clear_utime();
  static const int kUtimeFieldNumber = 1;
  inline ::google::protobuf::uint64 utime() const;
  inline void set_utime(::google::protobuf::uint64 value);
  
  // repeated .px.Obstacle obstacles = 2;
  inline int obstacles_size() const;
  inline void clear_obstacles();
  static const int kObstaclesFieldNumber = 2;
  inline const ::px::Obstacle& obstacles(int index) const;
  inline ::px::Obstacle* mutable_obstacles(int index);
  inline ::px::Obstacle* add_obstacles();
  inline const ::google::protobuf::RepeatedPtrField< ::px::Obstacle >&
      obstacles() const;
  inline ::google::protobuf::RepeatedPtrField< ::px::Obstacle >*
      mutable_obstacles();
  
  // @@protoc_insertion_point(class_scope:px.ObstacleList)
 private:
  inline void set_has_utime();
  inline void clear_has_utime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 utime_;
  ::google::protobuf::RepeatedPtrField< ::px::Obstacle > obstacles_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static ObstacleList* default_instance_;
};
// -------------------------------------------------------------------

class ObstacleMap : public ::google::protobuf::Message {
 public:
  ObstacleMap();
  virtual ~ObstacleMap();
  
  ObstacleMap(const ObstacleMap& from);
  
  inline ObstacleMap& operator=(const ObstacleMap& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleMap& default_instance();
  
  void Swap(ObstacleMap* other);
  
  // implements Message ----------------------------------------------
  
  ObstacleMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObstacleMap& from);
  void MergeFrom(const ObstacleMap& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 utime = 1;
  inline bool has_utime() const;
  inline void clear_utime();
  static const int kUtimeFieldNumber = 1;
  inline ::google::protobuf::uint64 utime() const;
  inline void set_utime(::google::protobuf::uint64 value);
  
  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional float resolution = 3;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 3;
  inline float resolution() const;
  inline void set_resolution(float value);
  
  // optional int32 rows = 4;
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 4;
  inline ::google::protobuf::int32 rows() const;
  inline void set_rows(::google::protobuf::int32 value);
  
  // optional int32 cols = 5;
  inline bool has_cols() const;
  inline void clear_cols();
  static const int kColsFieldNumber = 5;
  inline ::google::protobuf::int32 cols() const;
  inline void set_cols(::google::protobuf::int32 value);
  
  // optional int32 mapR0 = 6;
  inline bool has_mapr0() const;
  inline void clear_mapr0();
  static const int kMapR0FieldNumber = 6;
  inline ::google::protobuf::int32 mapr0() const;
  inline void set_mapr0(::google::protobuf::int32 value);
  
  // optional int32 mapC0 = 7;
  inline bool has_mapc0() const;
  inline void clear_mapc0();
  static const int kMapC0FieldNumber = 7;
  inline ::google::protobuf::int32 mapc0() const;
  inline void set_mapc0(::google::protobuf::int32 value);
  
  // optional int32 arrayR0 = 8;
  inline bool has_arrayr0() const;
  inline void clear_arrayr0();
  static const int kArrayR0FieldNumber = 8;
  inline ::google::protobuf::int32 arrayr0() const;
  inline void set_arrayr0(::google::protobuf::int32 value);
  
  // optional int32 arrayC0 = 9;
  inline bool has_arrayc0() const;
  inline void clear_arrayc0();
  static const int kArrayC0FieldNumber = 9;
  inline ::google::protobuf::int32 arrayc0() const;
  inline void set_arrayc0(::google::protobuf::int32 value);
  
  // optional bytes data = 10;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 10;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:px.ObstacleMap)
 private:
  inline void set_has_utime();
  inline void clear_has_utime();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_rows();
  inline void clear_has_rows();
  inline void set_has_cols();
  inline void clear_has_cols();
  inline void set_has_mapr0();
  inline void clear_has_mapr0();
  inline void set_has_mapc0();
  inline void clear_has_mapc0();
  inline void set_has_arrayr0();
  inline void clear_has_arrayr0();
  inline void set_has_arrayc0();
  inline void clear_has_arrayc0();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 utime_;
  ::google::protobuf::int32 type_;
  float resolution_;
  ::google::protobuf::int32 rows_;
  ::google::protobuf::int32 cols_;
  ::google::protobuf::int32 mapr0_;
  ::google::protobuf::int32 mapc0_;
  ::google::protobuf::int32 arrayr0_;
  ::google::protobuf::int32 arrayc0_;
  ::std::string* data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static ObstacleMap* default_instance_;
};
// ===================================================================


// ===================================================================

// PointCloudXYZI_PointXYZI

// required float x = 1;
inline bool PointCloudXYZI_PointXYZI::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointCloudXYZI_PointXYZI::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointCloudXYZI_PointXYZI::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointCloudXYZI_PointXYZI::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float PointCloudXYZI_PointXYZI::x() const {
  return x_;
}
inline void PointCloudXYZI_PointXYZI::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool PointCloudXYZI_PointXYZI::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointCloudXYZI_PointXYZI::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointCloudXYZI_PointXYZI::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointCloudXYZI_PointXYZI::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float PointCloudXYZI_PointXYZI::y() const {
  return y_;
}
inline void PointCloudXYZI_PointXYZI::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool PointCloudXYZI_PointXYZI::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointCloudXYZI_PointXYZI::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointCloudXYZI_PointXYZI::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointCloudXYZI_PointXYZI::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float PointCloudXYZI_PointXYZI::z() const {
  return z_;
}
inline void PointCloudXYZI_PointXYZI::set_z(float value) {
  set_has_z();
  z_ = value;
}

// required float intensity = 4;
inline bool PointCloudXYZI_PointXYZI::has_intensity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PointCloudXYZI_PointXYZI::set_has_intensity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PointCloudXYZI_PointXYZI::clear_has_intensity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PointCloudXYZI_PointXYZI::clear_intensity() {
  intensity_ = 0;
  clear_has_intensity();
}
inline float PointCloudXYZI_PointXYZI::intensity() const {
  return intensity_;
}
inline void PointCloudXYZI_PointXYZI::set_intensity(float value) {
  set_has_intensity();
  intensity_ = value;
}

// -------------------------------------------------------------------

// PointCloudXYZI

// repeated .px.PointCloudXYZI.PointXYZI points = 1;
inline int PointCloudXYZI::points_size() const {
  return points_.size();
}
inline void PointCloudXYZI::clear_points() {
  points_.Clear();
}
inline const ::px::PointCloudXYZI_PointXYZI& PointCloudXYZI::points(int index) const {
  return points_.Get(index);
}
inline ::px::PointCloudXYZI_PointXYZI* PointCloudXYZI::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::px::PointCloudXYZI_PointXYZI* PointCloudXYZI::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZI_PointXYZI >&
PointCloudXYZI::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZI_PointXYZI >*
PointCloudXYZI::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// PointCloudXYZRGB_PointXYZRGB

// required float x = 1;
inline bool PointCloudXYZRGB_PointXYZRGB::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float PointCloudXYZRGB_PointXYZRGB::x() const {
  return x_;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool PointCloudXYZRGB_PointXYZRGB::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float PointCloudXYZRGB_PointXYZRGB::y() const {
  return y_;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool PointCloudXYZRGB_PointXYZRGB::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float PointCloudXYZRGB_PointXYZRGB::z() const {
  return z_;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_z(float value) {
  set_has_z();
  z_ = value;
}

// required float rgb = 4;
inline bool PointCloudXYZRGB_PointXYZRGB::has_rgb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_has_rgb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_has_rgb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_rgb() {
  rgb_ = 0;
  clear_has_rgb();
}
inline float PointCloudXYZRGB_PointXYZRGB::rgb() const {
  return rgb_;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_rgb(float value) {
  set_has_rgb();
  rgb_ = value;
}

// -------------------------------------------------------------------

// PointCloudXYZRGB

// repeated .px.PointCloudXYZRGB.PointXYZRGB points = 1;
inline int PointCloudXYZRGB::points_size() const {
  return points_.size();
}
inline void PointCloudXYZRGB::clear_points() {
  points_.Clear();
}
inline const ::px::PointCloudXYZRGB_PointXYZRGB& PointCloudXYZRGB::points(int index) const {
  return points_.Get(index);
}
inline ::px::PointCloudXYZRGB_PointXYZRGB* PointCloudXYZRGB::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::px::PointCloudXYZRGB_PointXYZRGB* PointCloudXYZRGB::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZRGB_PointXYZRGB >&
PointCloudXYZRGB::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZRGB_PointXYZRGB >*
PointCloudXYZRGB::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// RGBDImage

// required uint32 cols = 1;
inline bool RGBDImage::has_cols() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RGBDImage::set_has_cols() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RGBDImage::clear_has_cols() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RGBDImage::clear_cols() {
  cols_ = 0u;
  clear_has_cols();
}
inline ::google::protobuf::uint32 RGBDImage::cols() const {
  return cols_;
}
inline void RGBDImage::set_cols(::google::protobuf::uint32 value) {
  set_has_cols();
  cols_ = value;
}

// required uint32 rows = 2;
inline bool RGBDImage::has_rows() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RGBDImage::set_has_rows() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RGBDImage::clear_has_rows() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RGBDImage::clear_rows() {
  rows_ = 0u;
  clear_has_rows();
}
inline ::google::protobuf::uint32 RGBDImage::rows() const {
  return rows_;
}
inline void RGBDImage::set_rows(::google::protobuf::uint32 value) {
  set_has_rows();
  rows_ = value;
}

// required uint32 step1 = 3;
inline bool RGBDImage::has_step1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RGBDImage::set_has_step1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RGBDImage::clear_has_step1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RGBDImage::clear_step1() {
  step1_ = 0u;
  clear_has_step1();
}
inline ::google::protobuf::uint32 RGBDImage::step1() const {
  return step1_;
}
inline void RGBDImage::set_step1(::google::protobuf::uint32 value) {
  set_has_step1();
  step1_ = value;
}

// required uint32 type1 = 4;
inline bool RGBDImage::has_type1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RGBDImage::set_has_type1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RGBDImage::clear_has_type1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RGBDImage::clear_type1() {
  type1_ = 0u;
  clear_has_type1();
}
inline ::google::protobuf::uint32 RGBDImage::type1() const {
  return type1_;
}
inline void RGBDImage::set_type1(::google::protobuf::uint32 value) {
  set_has_type1();
  type1_ = value;
}

// required bytes imageData1 = 5;
inline bool RGBDImage::has_imagedata1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RGBDImage::set_has_imagedata1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RGBDImage::clear_has_imagedata1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RGBDImage::clear_imagedata1() {
  if (imagedata1_ != &::google::protobuf::internal::kEmptyString) {
    imagedata1_->clear();
  }
  clear_has_imagedata1();
}
inline const ::std::string& RGBDImage::imagedata1() const {
  return *imagedata1_;
}
inline void RGBDImage::set_imagedata1(const ::std::string& value) {
  set_has_imagedata1();
  if (imagedata1_ == &::google::protobuf::internal::kEmptyString) {
    imagedata1_ = new ::std::string;
  }
  imagedata1_->assign(value);
}
inline void RGBDImage::set_imagedata1(const char* value) {
  set_has_imagedata1();
  if (imagedata1_ == &::google::protobuf::internal::kEmptyString) {
    imagedata1_ = new ::std::string;
  }
  imagedata1_->assign(value);
}
inline void RGBDImage::set_imagedata1(const void* value, size_t size) {
  set_has_imagedata1();
  if (imagedata1_ == &::google::protobuf::internal::kEmptyString) {
    imagedata1_ = new ::std::string;
  }
  imagedata1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RGBDImage::mutable_imagedata1() {
  set_has_imagedata1();
  if (imagedata1_ == &::google::protobuf::internal::kEmptyString) {
    imagedata1_ = new ::std::string;
  }
  return imagedata1_;
}
inline ::std::string* RGBDImage::release_imagedata1() {
  clear_has_imagedata1();
  if (imagedata1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imagedata1_;
    imagedata1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 step2 = 6;
inline bool RGBDImage::has_step2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RGBDImage::set_has_step2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RGBDImage::clear_has_step2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RGBDImage::clear_step2() {
  step2_ = 0u;
  clear_has_step2();
}
inline ::google::protobuf::uint32 RGBDImage::step2() const {
  return step2_;
}
inline void RGBDImage::set_step2(::google::protobuf::uint32 value) {
  set_has_step2();
  step2_ = value;
}

// required uint32 type2 = 7;
inline bool RGBDImage::has_type2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RGBDImage::set_has_type2() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RGBDImage::clear_has_type2() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RGBDImage::clear_type2() {
  type2_ = 0u;
  clear_has_type2();
}
inline ::google::protobuf::uint32 RGBDImage::type2() const {
  return type2_;
}
inline void RGBDImage::set_type2(::google::protobuf::uint32 value) {
  set_has_type2();
  type2_ = value;
}

// required bytes imageData2 = 8;
inline bool RGBDImage::has_imagedata2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RGBDImage::set_has_imagedata2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RGBDImage::clear_has_imagedata2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RGBDImage::clear_imagedata2() {
  if (imagedata2_ != &::google::protobuf::internal::kEmptyString) {
    imagedata2_->clear();
  }
  clear_has_imagedata2();
}
inline const ::std::string& RGBDImage::imagedata2() const {
  return *imagedata2_;
}
inline void RGBDImage::set_imagedata2(const ::std::string& value) {
  set_has_imagedata2();
  if (imagedata2_ == &::google::protobuf::internal::kEmptyString) {
    imagedata2_ = new ::std::string;
  }
  imagedata2_->assign(value);
}
inline void RGBDImage::set_imagedata2(const char* value) {
  set_has_imagedata2();
  if (imagedata2_ == &::google::protobuf::internal::kEmptyString) {
    imagedata2_ = new ::std::string;
  }
  imagedata2_->assign(value);
}
inline void RGBDImage::set_imagedata2(const void* value, size_t size) {
  set_has_imagedata2();
  if (imagedata2_ == &::google::protobuf::internal::kEmptyString) {
    imagedata2_ = new ::std::string;
  }
  imagedata2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RGBDImage::mutable_imagedata2() {
  set_has_imagedata2();
  if (imagedata2_ == &::google::protobuf::internal::kEmptyString) {
    imagedata2_ = new ::std::string;
  }
  return imagedata2_;
}
inline ::std::string* RGBDImage::release_imagedata2() {
  clear_has_imagedata2();
  if (imagedata2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imagedata2_;
    imagedata2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 camera_config = 9;
inline bool RGBDImage::has_camera_config() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RGBDImage::set_has_camera_config() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RGBDImage::clear_has_camera_config() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RGBDImage::clear_camera_config() {
  camera_config_ = 0u;
  clear_has_camera_config();
}
inline ::google::protobuf::uint32 RGBDImage::camera_config() const {
  return camera_config_;
}
inline void RGBDImage::set_camera_config(::google::protobuf::uint32 value) {
  set_has_camera_config();
  camera_config_ = value;
}

// optional uint32 camera_type = 10;
inline bool RGBDImage::has_camera_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RGBDImage::set_has_camera_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RGBDImage::clear_has_camera_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RGBDImage::clear_camera_type() {
  camera_type_ = 0u;
  clear_has_camera_type();
}
inline ::google::protobuf::uint32 RGBDImage::camera_type() const {
  return camera_type_;
}
inline void RGBDImage::set_camera_type(::google::protobuf::uint32 value) {
  set_has_camera_type();
  camera_type_ = value;
}

// optional uint64 timestamp = 11;
inline bool RGBDImage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RGBDImage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RGBDImage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RGBDImage::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 RGBDImage::timestamp() const {
  return timestamp_;
}
inline void RGBDImage::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional float roll = 12;
inline bool RGBDImage::has_roll() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RGBDImage::set_has_roll() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RGBDImage::clear_has_roll() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RGBDImage::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float RGBDImage::roll() const {
  return roll_;
}
inline void RGBDImage::set_roll(float value) {
  set_has_roll();
  roll_ = value;
}

// optional float pitch = 13;
inline bool RGBDImage::has_pitch() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RGBDImage::set_has_pitch() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RGBDImage::clear_has_pitch() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RGBDImage::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float RGBDImage::pitch() const {
  return pitch_;
}
inline void RGBDImage::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
}

// optional float yaw = 14;
inline bool RGBDImage::has_yaw() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RGBDImage::set_has_yaw() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RGBDImage::clear_has_yaw() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RGBDImage::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float RGBDImage::yaw() const {
  return yaw_;
}
inline void RGBDImage::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
}

// optional float lon = 15;
inline bool RGBDImage::has_lon() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RGBDImage::set_has_lon() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RGBDImage::clear_has_lon() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RGBDImage::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float RGBDImage::lon() const {
  return lon_;
}
inline void RGBDImage::set_lon(float value) {
  set_has_lon();
  lon_ = value;
}

// optional float lat = 16;
inline bool RGBDImage::has_lat() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RGBDImage::set_has_lat() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RGBDImage::clear_has_lat() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RGBDImage::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float RGBDImage::lat() const {
  return lat_;
}
inline void RGBDImage::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float alt = 17;
inline bool RGBDImage::has_alt() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RGBDImage::set_has_alt() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RGBDImage::clear_has_alt() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RGBDImage::clear_alt() {
  alt_ = 0;
  clear_has_alt();
}
inline float RGBDImage::alt() const {
  return alt_;
}
inline void RGBDImage::set_alt(float value) {
  set_has_alt();
  alt_ = value;
}

// optional float ground_x = 18;
inline bool RGBDImage::has_ground_x() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RGBDImage::set_has_ground_x() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RGBDImage::clear_has_ground_x() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RGBDImage::clear_ground_x() {
  ground_x_ = 0;
  clear_has_ground_x();
}
inline float RGBDImage::ground_x() const {
  return ground_x_;
}
inline void RGBDImage::set_ground_x(float value) {
  set_has_ground_x();
  ground_x_ = value;
}

// optional float ground_y = 19;
inline bool RGBDImage::has_ground_y() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RGBDImage::set_has_ground_y() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RGBDImage::clear_has_ground_y() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RGBDImage::clear_ground_y() {
  ground_y_ = 0;
  clear_has_ground_y();
}
inline float RGBDImage::ground_y() const {
  return ground_y_;
}
inline void RGBDImage::set_ground_y(float value) {
  set_has_ground_y();
  ground_y_ = value;
}

// optional float ground_z = 20;
inline bool RGBDImage::has_ground_z() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RGBDImage::set_has_ground_z() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RGBDImage::clear_has_ground_z() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RGBDImage::clear_ground_z() {
  ground_z_ = 0;
  clear_has_ground_z();
}
inline float RGBDImage::ground_z() const {
  return ground_z_;
}
inline void RGBDImage::set_ground_z(float value) {
  set_has_ground_z();
  ground_z_ = value;
}

// repeated float camera_matrix = 21;
inline int RGBDImage::camera_matrix_size() const {
  return camera_matrix_.size();
}
inline void RGBDImage::clear_camera_matrix() {
  camera_matrix_.Clear();
}
inline float RGBDImage::camera_matrix(int index) const {
  return camera_matrix_.Get(index);
}
inline void RGBDImage::set_camera_matrix(int index, float value) {
  camera_matrix_.Set(index, value);
}
inline void RGBDImage::add_camera_matrix(float value) {
  camera_matrix_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RGBDImage::camera_matrix() const {
  return camera_matrix_;
}
inline ::google::protobuf::RepeatedField< float >*
RGBDImage::mutable_camera_matrix() {
  return &camera_matrix_;
}

// -------------------------------------------------------------------

// Obstacle

// optional float x = 1;
inline bool Obstacle::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Obstacle::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Obstacle::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Obstacle::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Obstacle::x() const {
  return x_;
}
inline void Obstacle::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 2;
inline bool Obstacle::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Obstacle::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Obstacle::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Obstacle::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Obstacle::y() const {
  return y_;
}
inline void Obstacle::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional float z = 3;
inline bool Obstacle::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Obstacle::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Obstacle::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Obstacle::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Obstacle::z() const {
  return z_;
}
inline void Obstacle::set_z(float value) {
  set_has_z();
  z_ = value;
}

// optional float length = 4;
inline bool Obstacle::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Obstacle::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Obstacle::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Obstacle::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float Obstacle::length() const {
  return length_;
}
inline void Obstacle::set_length(float value) {
  set_has_length();
  length_ = value;
}

// optional float width = 5;
inline bool Obstacle::has_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Obstacle::set_has_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Obstacle::clear_has_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Obstacle::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float Obstacle::width() const {
  return width_;
}
inline void Obstacle::set_width(float value) {
  set_has_width();
  width_ = value;
}

// optional float height = 6;
inline bool Obstacle::has_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Obstacle::set_has_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Obstacle::clear_has_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Obstacle::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float Obstacle::height() const {
  return height_;
}
inline void Obstacle::set_height(float value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// ObstacleList

// optional uint64 utime = 1;
inline bool ObstacleList::has_utime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObstacleList::set_has_utime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObstacleList::clear_has_utime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObstacleList::clear_utime() {
  utime_ = GOOGLE_ULONGLONG(0);
  clear_has_utime();
}
inline ::google::protobuf::uint64 ObstacleList::utime() const {
  return utime_;
}
inline void ObstacleList::set_utime(::google::protobuf::uint64 value) {
  set_has_utime();
  utime_ = value;
}

// repeated .px.Obstacle obstacles = 2;
inline int ObstacleList::obstacles_size() const {
  return obstacles_.size();
}
inline void ObstacleList::clear_obstacles() {
  obstacles_.Clear();
}
inline const ::px::Obstacle& ObstacleList::obstacles(int index) const {
  return obstacles_.Get(index);
}
inline ::px::Obstacle* ObstacleList::mutable_obstacles(int index) {
  return obstacles_.Mutable(index);
}
inline ::px::Obstacle* ObstacleList::add_obstacles() {
  return obstacles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::px::Obstacle >&
ObstacleList::obstacles() const {
  return obstacles_;
}
inline ::google::protobuf::RepeatedPtrField< ::px::Obstacle >*
ObstacleList::mutable_obstacles() {
  return &obstacles_;
}

// -------------------------------------------------------------------

// ObstacleMap

// required uint64 utime = 1;
inline bool ObstacleMap::has_utime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObstacleMap::set_has_utime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObstacleMap::clear_has_utime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObstacleMap::clear_utime() {
  utime_ = GOOGLE_ULONGLONG(0);
  clear_has_utime();
}
inline ::google::protobuf::uint64 ObstacleMap::utime() const {
  return utime_;
}
inline void ObstacleMap::set_utime(::google::protobuf::uint64 value) {
  set_has_utime();
  utime_ = value;
}

// required int32 type = 2;
inline bool ObstacleMap::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObstacleMap::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObstacleMap::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObstacleMap::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ObstacleMap::type() const {
  return type_;
}
inline void ObstacleMap::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional float resolution = 3;
inline bool ObstacleMap::has_resolution() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObstacleMap::set_has_resolution() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObstacleMap::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObstacleMap::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline float ObstacleMap::resolution() const {
  return resolution_;
}
inline void ObstacleMap::set_resolution(float value) {
  set_has_resolution();
  resolution_ = value;
}

// optional int32 rows = 4;
inline bool ObstacleMap::has_rows() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObstacleMap::set_has_rows() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObstacleMap::clear_has_rows() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObstacleMap::clear_rows() {
  rows_ = 0;
  clear_has_rows();
}
inline ::google::protobuf::int32 ObstacleMap::rows() const {
  return rows_;
}
inline void ObstacleMap::set_rows(::google::protobuf::int32 value) {
  set_has_rows();
  rows_ = value;
}

// optional int32 cols = 5;
inline bool ObstacleMap::has_cols() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ObstacleMap::set_has_cols() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ObstacleMap::clear_has_cols() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ObstacleMap::clear_cols() {
  cols_ = 0;
  clear_has_cols();
}
inline ::google::protobuf::int32 ObstacleMap::cols() const {
  return cols_;
}
inline void ObstacleMap::set_cols(::google::protobuf::int32 value) {
  set_has_cols();
  cols_ = value;
}

// optional int32 mapR0 = 6;
inline bool ObstacleMap::has_mapr0() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ObstacleMap::set_has_mapr0() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ObstacleMap::clear_has_mapr0() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ObstacleMap::clear_mapr0() {
  mapr0_ = 0;
  clear_has_mapr0();
}
inline ::google::protobuf::int32 ObstacleMap::mapr0() const {
  return mapr0_;
}
inline void ObstacleMap::set_mapr0(::google::protobuf::int32 value) {
  set_has_mapr0();
  mapr0_ = value;
}

// optional int32 mapC0 = 7;
inline bool ObstacleMap::has_mapc0() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ObstacleMap::set_has_mapc0() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ObstacleMap::clear_has_mapc0() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ObstacleMap::clear_mapc0() {
  mapc0_ = 0;
  clear_has_mapc0();
}
inline ::google::protobuf::int32 ObstacleMap::mapc0() const {
  return mapc0_;
}
inline void ObstacleMap::set_mapc0(::google::protobuf::int32 value) {
  set_has_mapc0();
  mapc0_ = value;
}

// optional int32 arrayR0 = 8;
inline bool ObstacleMap::has_arrayr0() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ObstacleMap::set_has_arrayr0() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ObstacleMap::clear_has_arrayr0() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ObstacleMap::clear_arrayr0() {
  arrayr0_ = 0;
  clear_has_arrayr0();
}
inline ::google::protobuf::int32 ObstacleMap::arrayr0() const {
  return arrayr0_;
}
inline void ObstacleMap::set_arrayr0(::google::protobuf::int32 value) {
  set_has_arrayr0();
  arrayr0_ = value;
}

// optional int32 arrayC0 = 9;
inline bool ObstacleMap::has_arrayc0() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ObstacleMap::set_has_arrayc0() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ObstacleMap::clear_has_arrayc0() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ObstacleMap::clear_arrayc0() {
  arrayc0_ = 0;
  clear_has_arrayc0();
}
inline ::google::protobuf::int32 ObstacleMap::arrayc0() const {
  return arrayc0_;
}
inline void ObstacleMap::set_arrayc0(::google::protobuf::int32 value) {
  set_has_arrayc0();
  arrayc0_ = value;
}

// optional bytes data = 10;
inline bool ObstacleMap::has_data() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ObstacleMap::set_has_data() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ObstacleMap::clear_has_data() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ObstacleMap::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ObstacleMap::data() const {
  return *data_;
}
inline void ObstacleMap::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ObstacleMap::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ObstacleMap::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObstacleMap::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ObstacleMap::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace px

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pixhawk_2eproto__INCLUDED
