// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pixhawk.proto

#ifndef PROTOBUF_pixhawk_2eproto__INCLUDED
#define PROTOBUF_pixhawk_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace px {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pixhawk_2eproto();
void protobuf_AssignDesc_pixhawk_2eproto();
void protobuf_ShutdownFile_pixhawk_2eproto();

class HeaderInfo;
class GLOverlay;
class Obstacle;
class ObstacleList;
class ObstacleMap;
class Path;
class PointCloudXYZI;
class PointCloudXYZI_PointXYZI;
class PointCloudXYZRGB;
class PointCloudXYZRGB_PointXYZRGB;
class RGBDImage;
class Waypoint;

enum GLOverlay_CoordinateFrameType {
  GLOverlay_CoordinateFrameType_GLOBAL = 0,
  GLOverlay_CoordinateFrameType_LOCAL = 1
};
bool GLOverlay_CoordinateFrameType_IsValid(int value);
const GLOverlay_CoordinateFrameType GLOverlay_CoordinateFrameType_CoordinateFrameType_MIN = GLOverlay_CoordinateFrameType_GLOBAL;
const GLOverlay_CoordinateFrameType GLOverlay_CoordinateFrameType_CoordinateFrameType_MAX = GLOverlay_CoordinateFrameType_LOCAL;
const int GLOverlay_CoordinateFrameType_CoordinateFrameType_ARRAYSIZE = GLOverlay_CoordinateFrameType_CoordinateFrameType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GLOverlay_CoordinateFrameType_descriptor();
inline const ::std::string& GLOverlay_CoordinateFrameType_Name(GLOverlay_CoordinateFrameType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GLOverlay_CoordinateFrameType_descriptor(), value);
}
inline bool GLOverlay_CoordinateFrameType_Parse(
    const ::std::string& name, GLOverlay_CoordinateFrameType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GLOverlay_CoordinateFrameType>(
    GLOverlay_CoordinateFrameType_descriptor(), name, value);
}
enum GLOverlay_Mode {
  GLOverlay_Mode_POINTS = 0,
  GLOverlay_Mode_LINES = 1,
  GLOverlay_Mode_LINE_STRIP = 2,
  GLOverlay_Mode_LINE_LOOP = 3,
  GLOverlay_Mode_TRIANGLES = 4,
  GLOverlay_Mode_TRIANGLE_STRIP = 5,
  GLOverlay_Mode_TRIANGLE_FAN = 6,
  GLOverlay_Mode_QUADS = 7,
  GLOverlay_Mode_QUAD_STRIP = 8,
  GLOverlay_Mode_POLYGON = 9,
  GLOverlay_Mode_SOLID_CIRCLE = 10,
  GLOverlay_Mode_WIRE_CIRCLE = 11,
  GLOverlay_Mode_SOLID_CUBE = 12,
  GLOverlay_Mode_WIRE_CUBE = 13
};
bool GLOverlay_Mode_IsValid(int value);
const GLOverlay_Mode GLOverlay_Mode_Mode_MIN = GLOverlay_Mode_POINTS;
const GLOverlay_Mode GLOverlay_Mode_Mode_MAX = GLOverlay_Mode_WIRE_CUBE;
const int GLOverlay_Mode_Mode_ARRAYSIZE = GLOverlay_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GLOverlay_Mode_descriptor();
inline const ::std::string& GLOverlay_Mode_Name(GLOverlay_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GLOverlay_Mode_descriptor(), value);
}
inline bool GLOverlay_Mode_Parse(
    const ::std::string& name, GLOverlay_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GLOverlay_Mode>(
    GLOverlay_Mode_descriptor(), name, value);
}
enum GLOverlay_Identifier {
  GLOverlay_Identifier_END = 14,
  GLOverlay_Identifier_VERTEX2F = 15,
  GLOverlay_Identifier_VERTEX3F = 16,
  GLOverlay_Identifier_ROTATEF = 17,
  GLOverlay_Identifier_TRANSLATEF = 18,
  GLOverlay_Identifier_SCALEF = 19,
  GLOverlay_Identifier_PUSH_MATRIX = 20,
  GLOverlay_Identifier_POP_MATRIX = 21,
  GLOverlay_Identifier_COLOR3F = 22,
  GLOverlay_Identifier_COLOR4F = 23,
  GLOverlay_Identifier_POINTSIZE = 24,
  GLOverlay_Identifier_LINEWIDTH = 25
};
bool GLOverlay_Identifier_IsValid(int value);
const GLOverlay_Identifier GLOverlay_Identifier_Identifier_MIN = GLOverlay_Identifier_END;
const GLOverlay_Identifier GLOverlay_Identifier_Identifier_MAX = GLOverlay_Identifier_LINEWIDTH;
const int GLOverlay_Identifier_Identifier_ARRAYSIZE = GLOverlay_Identifier_Identifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* GLOverlay_Identifier_descriptor();
inline const ::std::string& GLOverlay_Identifier_Name(GLOverlay_Identifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    GLOverlay_Identifier_descriptor(), value);
}
inline bool GLOverlay_Identifier_Parse(
    const ::std::string& name, GLOverlay_Identifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GLOverlay_Identifier>(
    GLOverlay_Identifier_descriptor(), name, value);
}
// ===================================================================

class HeaderInfo : public ::google::protobuf::Message {
 public:
  HeaderInfo();
  virtual ~HeaderInfo();
  
  HeaderInfo(const HeaderInfo& from);
  
  inline HeaderInfo& operator=(const HeaderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeaderInfo& default_instance();
  
  void Swap(HeaderInfo* other);
  
  // implements Message ----------------------------------------------
  
  HeaderInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeaderInfo& from);
  void MergeFrom(const HeaderInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 source_sysid = 1;
  inline bool has_source_sysid() const;
  inline void clear_source_sysid();
  static const int kSourceSysidFieldNumber = 1;
  inline ::google::protobuf::int32 source_sysid() const;
  inline void set_source_sysid(::google::protobuf::int32 value);
  
  // required int32 source_compid = 2;
  inline bool has_source_compid() const;
  inline void clear_source_compid();
  static const int kSourceCompidFieldNumber = 2;
  inline ::google::protobuf::int32 source_compid() const;
  inline void set_source_compid(::google::protobuf::int32 value);
  
  // required double timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline double timestamp() const;
  inline void set_timestamp(double value);
  
  // @@protoc_insertion_point(class_scope:px.HeaderInfo)
 private:
  inline void set_has_source_sysid();
  inline void clear_has_source_sysid();
  inline void set_has_source_compid();
  inline void clear_has_source_compid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 source_sysid_;
  ::google::protobuf::int32 source_compid_;
  double timestamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static HeaderInfo* default_instance_;
};
// -------------------------------------------------------------------

class GLOverlay : public ::google::protobuf::Message {
 public:
  GLOverlay();
  virtual ~GLOverlay();
  
  GLOverlay(const GLOverlay& from);
  
  inline GLOverlay& operator=(const GLOverlay& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GLOverlay& default_instance();
  
  void Swap(GLOverlay* other);
  
  // implements Message ----------------------------------------------
  
  GLOverlay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GLOverlay& from);
  void MergeFrom(const GLOverlay& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef GLOverlay_CoordinateFrameType CoordinateFrameType;
  static const CoordinateFrameType GLOBAL = GLOverlay_CoordinateFrameType_GLOBAL;
  static const CoordinateFrameType LOCAL = GLOverlay_CoordinateFrameType_LOCAL;
  static inline bool CoordinateFrameType_IsValid(int value) {
    return GLOverlay_CoordinateFrameType_IsValid(value);
  }
  static const CoordinateFrameType CoordinateFrameType_MIN =
    GLOverlay_CoordinateFrameType_CoordinateFrameType_MIN;
  static const CoordinateFrameType CoordinateFrameType_MAX =
    GLOverlay_CoordinateFrameType_CoordinateFrameType_MAX;
  static const int CoordinateFrameType_ARRAYSIZE =
    GLOverlay_CoordinateFrameType_CoordinateFrameType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CoordinateFrameType_descriptor() {
    return GLOverlay_CoordinateFrameType_descriptor();
  }
  static inline const ::std::string& CoordinateFrameType_Name(CoordinateFrameType value) {
    return GLOverlay_CoordinateFrameType_Name(value);
  }
  static inline bool CoordinateFrameType_Parse(const ::std::string& name,
      CoordinateFrameType* value) {
    return GLOverlay_CoordinateFrameType_Parse(name, value);
  }
  
  typedef GLOverlay_Mode Mode;
  static const Mode POINTS = GLOverlay_Mode_POINTS;
  static const Mode LINES = GLOverlay_Mode_LINES;
  static const Mode LINE_STRIP = GLOverlay_Mode_LINE_STRIP;
  static const Mode LINE_LOOP = GLOverlay_Mode_LINE_LOOP;
  static const Mode TRIANGLES = GLOverlay_Mode_TRIANGLES;
  static const Mode TRIANGLE_STRIP = GLOverlay_Mode_TRIANGLE_STRIP;
  static const Mode TRIANGLE_FAN = GLOverlay_Mode_TRIANGLE_FAN;
  static const Mode QUADS = GLOverlay_Mode_QUADS;
  static const Mode QUAD_STRIP = GLOverlay_Mode_QUAD_STRIP;
  static const Mode POLYGON = GLOverlay_Mode_POLYGON;
  static const Mode SOLID_CIRCLE = GLOverlay_Mode_SOLID_CIRCLE;
  static const Mode WIRE_CIRCLE = GLOverlay_Mode_WIRE_CIRCLE;
  static const Mode SOLID_CUBE = GLOverlay_Mode_SOLID_CUBE;
  static const Mode WIRE_CUBE = GLOverlay_Mode_WIRE_CUBE;
  static inline bool Mode_IsValid(int value) {
    return GLOverlay_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    GLOverlay_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    GLOverlay_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    GLOverlay_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return GLOverlay_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return GLOverlay_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return GLOverlay_Mode_Parse(name, value);
  }
  
  typedef GLOverlay_Identifier Identifier;
  static const Identifier END = GLOverlay_Identifier_END;
  static const Identifier VERTEX2F = GLOverlay_Identifier_VERTEX2F;
  static const Identifier VERTEX3F = GLOverlay_Identifier_VERTEX3F;
  static const Identifier ROTATEF = GLOverlay_Identifier_ROTATEF;
  static const Identifier TRANSLATEF = GLOverlay_Identifier_TRANSLATEF;
  static const Identifier SCALEF = GLOverlay_Identifier_SCALEF;
  static const Identifier PUSH_MATRIX = GLOverlay_Identifier_PUSH_MATRIX;
  static const Identifier POP_MATRIX = GLOverlay_Identifier_POP_MATRIX;
  static const Identifier COLOR3F = GLOverlay_Identifier_COLOR3F;
  static const Identifier COLOR4F = GLOverlay_Identifier_COLOR4F;
  static const Identifier POINTSIZE = GLOverlay_Identifier_POINTSIZE;
  static const Identifier LINEWIDTH = GLOverlay_Identifier_LINEWIDTH;
  static inline bool Identifier_IsValid(int value) {
    return GLOverlay_Identifier_IsValid(value);
  }
  static const Identifier Identifier_MIN =
    GLOverlay_Identifier_Identifier_MIN;
  static const Identifier Identifier_MAX =
    GLOverlay_Identifier_Identifier_MAX;
  static const int Identifier_ARRAYSIZE =
    GLOverlay_Identifier_Identifier_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Identifier_descriptor() {
    return GLOverlay_Identifier_descriptor();
  }
  static inline const ::std::string& Identifier_Name(Identifier value) {
    return GLOverlay_Identifier_Name(value);
  }
  static inline bool Identifier_Parse(const ::std::string& name,
      Identifier* value) {
    return GLOverlay_Identifier_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .px.HeaderInfo header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::px::HeaderInfo& header() const;
  inline ::px::HeaderInfo* mutable_header();
  inline ::px::HeaderInfo* release_header();
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional .px.GLOverlay.CoordinateFrameType coordinateFrameType = 3;
  inline bool has_coordinateframetype() const;
  inline void clear_coordinateframetype();
  static const int kCoordinateFrameTypeFieldNumber = 3;
  inline ::px::GLOverlay_CoordinateFrameType coordinateframetype() const;
  inline void set_coordinateframetype(::px::GLOverlay_CoordinateFrameType value);
  
  // optional double origin_x = 4;
  inline bool has_origin_x() const;
  inline void clear_origin_x();
  static const int kOriginXFieldNumber = 4;
  inline double origin_x() const;
  inline void set_origin_x(double value);
  
  // optional double origin_y = 5;
  inline bool has_origin_y() const;
  inline void clear_origin_y();
  static const int kOriginYFieldNumber = 5;
  inline double origin_y() const;
  inline void set_origin_y(double value);
  
  // optional double origin_z = 6;
  inline bool has_origin_z() const;
  inline void clear_origin_z();
  static const int kOriginZFieldNumber = 6;
  inline double origin_z() const;
  inline void set_origin_z(double value);
  
  // optional bytes data = 7;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 7;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:px.GLOverlay)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_coordinateframetype();
  inline void clear_has_coordinateframetype();
  inline void set_has_origin_x();
  inline void clear_has_origin_x();
  inline void set_has_origin_y();
  inline void clear_has_origin_y();
  inline void set_has_origin_z();
  inline void clear_has_origin_z();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::px::HeaderInfo* header_;
  ::std::string* name_;
  double origin_x_;
  double origin_y_;
  double origin_z_;
  ::std::string* data_;
  int coordinateframetype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static GLOverlay* default_instance_;
};
// -------------------------------------------------------------------

class Obstacle : public ::google::protobuf::Message {
 public:
  Obstacle();
  virtual ~Obstacle();
  
  Obstacle(const Obstacle& from);
  
  inline Obstacle& operator=(const Obstacle& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Obstacle& default_instance();
  
  void Swap(Obstacle* other);
  
  // implements Message ----------------------------------------------
  
  Obstacle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Obstacle& from);
  void MergeFrom(const Obstacle& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);
  
  // optional float length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  inline float length() const;
  inline void set_length(float value);
  
  // optional float width = 5;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 5;
  inline float width() const;
  inline void set_width(float value);
  
  // optional float height = 6;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 6;
  inline float height() const;
  inline void set_height(float value);
  
  // @@protoc_insertion_point(class_scope:px.Obstacle)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float z_;
  float length_;
  float width_;
  float height_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static Obstacle* default_instance_;
};
// -------------------------------------------------------------------

class ObstacleList : public ::google::protobuf::Message {
 public:
  ObstacleList();
  virtual ~ObstacleList();
  
  ObstacleList(const ObstacleList& from);
  
  inline ObstacleList& operator=(const ObstacleList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleList& default_instance();
  
  void Swap(ObstacleList* other);
  
  // implements Message ----------------------------------------------
  
  ObstacleList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObstacleList& from);
  void MergeFrom(const ObstacleList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .px.HeaderInfo header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::px::HeaderInfo& header() const;
  inline ::px::HeaderInfo* mutable_header();
  inline ::px::HeaderInfo* release_header();
  
  // repeated .px.Obstacle obstacles = 2;
  inline int obstacles_size() const;
  inline void clear_obstacles();
  static const int kObstaclesFieldNumber = 2;
  inline const ::px::Obstacle& obstacles(int index) const;
  inline ::px::Obstacle* mutable_obstacles(int index);
  inline ::px::Obstacle* add_obstacles();
  inline const ::google::protobuf::RepeatedPtrField< ::px::Obstacle >&
      obstacles() const;
  inline ::google::protobuf::RepeatedPtrField< ::px::Obstacle >*
      mutable_obstacles();
  
  // @@protoc_insertion_point(class_scope:px.ObstacleList)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::px::HeaderInfo* header_;
  ::google::protobuf::RepeatedPtrField< ::px::Obstacle > obstacles_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static ObstacleList* default_instance_;
};
// -------------------------------------------------------------------

class ObstacleMap : public ::google::protobuf::Message {
 public:
  ObstacleMap();
  virtual ~ObstacleMap();
  
  ObstacleMap(const ObstacleMap& from);
  
  inline ObstacleMap& operator=(const ObstacleMap& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleMap& default_instance();
  
  void Swap(ObstacleMap* other);
  
  // implements Message ----------------------------------------------
  
  ObstacleMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObstacleMap& from);
  void MergeFrom(const ObstacleMap& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .px.HeaderInfo header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::px::HeaderInfo& header() const;
  inline ::px::HeaderInfo* mutable_header();
  inline ::px::HeaderInfo* release_header();
  
  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional float resolution = 3;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 3;
  inline float resolution() const;
  inline void set_resolution(float value);
  
  // optional int32 rows = 4;
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 4;
  inline ::google::protobuf::int32 rows() const;
  inline void set_rows(::google::protobuf::int32 value);
  
  // optional int32 cols = 5;
  inline bool has_cols() const;
  inline void clear_cols();
  static const int kColsFieldNumber = 5;
  inline ::google::protobuf::int32 cols() const;
  inline void set_cols(::google::protobuf::int32 value);
  
  // optional int32 mapR0 = 6;
  inline bool has_mapr0() const;
  inline void clear_mapr0();
  static const int kMapR0FieldNumber = 6;
  inline ::google::protobuf::int32 mapr0() const;
  inline void set_mapr0(::google::protobuf::int32 value);
  
  // optional int32 mapC0 = 7;
  inline bool has_mapc0() const;
  inline void clear_mapc0();
  static const int kMapC0FieldNumber = 7;
  inline ::google::protobuf::int32 mapc0() const;
  inline void set_mapc0(::google::protobuf::int32 value);
  
  // optional int32 arrayR0 = 8;
  inline bool has_arrayr0() const;
  inline void clear_arrayr0();
  static const int kArrayR0FieldNumber = 8;
  inline ::google::protobuf::int32 arrayr0() const;
  inline void set_arrayr0(::google::protobuf::int32 value);
  
  // optional int32 arrayC0 = 9;
  inline bool has_arrayc0() const;
  inline void clear_arrayc0();
  static const int kArrayC0FieldNumber = 9;
  inline ::google::protobuf::int32 arrayc0() const;
  inline void set_arrayc0(::google::protobuf::int32 value);
  
  // optional bytes data = 10;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 10;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:px.ObstacleMap)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_rows();
  inline void clear_has_rows();
  inline void set_has_cols();
  inline void clear_has_cols();
  inline void set_has_mapr0();
  inline void clear_has_mapr0();
  inline void set_has_mapc0();
  inline void clear_has_mapc0();
  inline void set_has_arrayr0();
  inline void clear_has_arrayr0();
  inline void set_has_arrayc0();
  inline void clear_has_arrayc0();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::px::HeaderInfo* header_;
  ::google::protobuf::int32 type_;
  float resolution_;
  ::google::protobuf::int32 rows_;
  ::google::protobuf::int32 cols_;
  ::google::protobuf::int32 mapr0_;
  ::google::protobuf::int32 mapc0_;
  ::google::protobuf::int32 arrayr0_;
  ::google::protobuf::int32 arrayc0_;
  ::std::string* data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static ObstacleMap* default_instance_;
};
// -------------------------------------------------------------------

class Path : public ::google::protobuf::Message {
 public:
  Path();
  virtual ~Path();
  
  Path(const Path& from);
  
  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Path& default_instance();
  
  void Swap(Path* other);
  
  // implements Message ----------------------------------------------
  
  Path* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Path& from);
  void MergeFrom(const Path& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .px.HeaderInfo header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::px::HeaderInfo& header() const;
  inline ::px::HeaderInfo* mutable_header();
  inline ::px::HeaderInfo* release_header();
  
  // repeated .px.Waypoint waypoints = 2;
  inline int waypoints_size() const;
  inline void clear_waypoints();
  static const int kWaypointsFieldNumber = 2;
  inline const ::px::Waypoint& waypoints(int index) const;
  inline ::px::Waypoint* mutable_waypoints(int index);
  inline ::px::Waypoint* add_waypoints();
  inline const ::google::protobuf::RepeatedPtrField< ::px::Waypoint >&
      waypoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::px::Waypoint >*
      mutable_waypoints();
  
  // @@protoc_insertion_point(class_scope:px.Path)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::px::HeaderInfo* header_;
  ::google::protobuf::RepeatedPtrField< ::px::Waypoint > waypoints_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static Path* default_instance_;
};
// -------------------------------------------------------------------

class PointCloudXYZI_PointXYZI : public ::google::protobuf::Message {
 public:
  PointCloudXYZI_PointXYZI();
  virtual ~PointCloudXYZI_PointXYZI();
  
  PointCloudXYZI_PointXYZI(const PointCloudXYZI_PointXYZI& from);
  
  inline PointCloudXYZI_PointXYZI& operator=(const PointCloudXYZI_PointXYZI& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloudXYZI_PointXYZI& default_instance();
  
  void Swap(PointCloudXYZI_PointXYZI* other);
  
  // implements Message ----------------------------------------------
  
  PointCloudXYZI_PointXYZI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointCloudXYZI_PointXYZI& from);
  void MergeFrom(const PointCloudXYZI_PointXYZI& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);
  
  // required float intensity = 4;
  inline bool has_intensity() const;
  inline void clear_intensity();
  static const int kIntensityFieldNumber = 4;
  inline float intensity() const;
  inline void set_intensity(float value);
  
  // @@protoc_insertion_point(class_scope:px.PointCloudXYZI.PointXYZI)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_intensity();
  inline void clear_has_intensity();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float z_;
  float intensity_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static PointCloudXYZI_PointXYZI* default_instance_;
};
// -------------------------------------------------------------------

class PointCloudXYZI : public ::google::protobuf::Message {
 public:
  PointCloudXYZI();
  virtual ~PointCloudXYZI();
  
  PointCloudXYZI(const PointCloudXYZI& from);
  
  inline PointCloudXYZI& operator=(const PointCloudXYZI& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloudXYZI& default_instance();
  
  void Swap(PointCloudXYZI* other);
  
  // implements Message ----------------------------------------------
  
  PointCloudXYZI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointCloudXYZI& from);
  void MergeFrom(const PointCloudXYZI& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef PointCloudXYZI_PointXYZI PointXYZI;
  
  // accessors -------------------------------------------------------
  
  // required .px.HeaderInfo header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::px::HeaderInfo& header() const;
  inline ::px::HeaderInfo* mutable_header();
  inline ::px::HeaderInfo* release_header();
  
  // repeated .px.PointCloudXYZI.PointXYZI points = 2;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 2;
  inline const ::px::PointCloudXYZI_PointXYZI& points(int index) const;
  inline ::px::PointCloudXYZI_PointXYZI* mutable_points(int index);
  inline ::px::PointCloudXYZI_PointXYZI* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZI_PointXYZI >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZI_PointXYZI >*
      mutable_points();
  
  // @@protoc_insertion_point(class_scope:px.PointCloudXYZI)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::px::HeaderInfo* header_;
  ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZI_PointXYZI > points_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static PointCloudXYZI* default_instance_;
};
// -------------------------------------------------------------------

class PointCloudXYZRGB_PointXYZRGB : public ::google::protobuf::Message {
 public:
  PointCloudXYZRGB_PointXYZRGB();
  virtual ~PointCloudXYZRGB_PointXYZRGB();
  
  PointCloudXYZRGB_PointXYZRGB(const PointCloudXYZRGB_PointXYZRGB& from);
  
  inline PointCloudXYZRGB_PointXYZRGB& operator=(const PointCloudXYZRGB_PointXYZRGB& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloudXYZRGB_PointXYZRGB& default_instance();
  
  void Swap(PointCloudXYZRGB_PointXYZRGB* other);
  
  // implements Message ----------------------------------------------
  
  PointCloudXYZRGB_PointXYZRGB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointCloudXYZRGB_PointXYZRGB& from);
  void MergeFrom(const PointCloudXYZRGB_PointXYZRGB& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);
  
  // required float rgb = 4;
  inline bool has_rgb() const;
  inline void clear_rgb();
  static const int kRgbFieldNumber = 4;
  inline float rgb() const;
  inline void set_rgb(float value);
  
  // @@protoc_insertion_point(class_scope:px.PointCloudXYZRGB.PointXYZRGB)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_rgb();
  inline void clear_has_rgb();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float z_;
  float rgb_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static PointCloudXYZRGB_PointXYZRGB* default_instance_;
};
// -------------------------------------------------------------------

class PointCloudXYZRGB : public ::google::protobuf::Message {
 public:
  PointCloudXYZRGB();
  virtual ~PointCloudXYZRGB();
  
  PointCloudXYZRGB(const PointCloudXYZRGB& from);
  
  inline PointCloudXYZRGB& operator=(const PointCloudXYZRGB& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloudXYZRGB& default_instance();
  
  void Swap(PointCloudXYZRGB* other);
  
  // implements Message ----------------------------------------------
  
  PointCloudXYZRGB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointCloudXYZRGB& from);
  void MergeFrom(const PointCloudXYZRGB& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef PointCloudXYZRGB_PointXYZRGB PointXYZRGB;
  
  // accessors -------------------------------------------------------
  
  // required .px.HeaderInfo header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::px::HeaderInfo& header() const;
  inline ::px::HeaderInfo* mutable_header();
  inline ::px::HeaderInfo* release_header();
  
  // repeated .px.PointCloudXYZRGB.PointXYZRGB points = 2;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 2;
  inline const ::px::PointCloudXYZRGB_PointXYZRGB& points(int index) const;
  inline ::px::PointCloudXYZRGB_PointXYZRGB* mutable_points(int index);
  inline ::px::PointCloudXYZRGB_PointXYZRGB* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZRGB_PointXYZRGB >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZRGB_PointXYZRGB >*
      mutable_points();
  
  // @@protoc_insertion_point(class_scope:px.PointCloudXYZRGB)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::px::HeaderInfo* header_;
  ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZRGB_PointXYZRGB > points_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static PointCloudXYZRGB* default_instance_;
};
// -------------------------------------------------------------------

class RGBDImage : public ::google::protobuf::Message {
 public:
  RGBDImage();
  virtual ~RGBDImage();
  
  RGBDImage(const RGBDImage& from);
  
  inline RGBDImage& operator=(const RGBDImage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RGBDImage& default_instance();
  
  void Swap(RGBDImage* other);
  
  // implements Message ----------------------------------------------
  
  RGBDImage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RGBDImage& from);
  void MergeFrom(const RGBDImage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .px.HeaderInfo header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::px::HeaderInfo& header() const;
  inline ::px::HeaderInfo* mutable_header();
  inline ::px::HeaderInfo* release_header();
  
  // required uint32 cols = 2;
  inline bool has_cols() const;
  inline void clear_cols();
  static const int kColsFieldNumber = 2;
  inline ::google::protobuf::uint32 cols() const;
  inline void set_cols(::google::protobuf::uint32 value);
  
  // required uint32 rows = 3;
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 3;
  inline ::google::protobuf::uint32 rows() const;
  inline void set_rows(::google::protobuf::uint32 value);
  
  // required uint32 step1 = 4;
  inline bool has_step1() const;
  inline void clear_step1();
  static const int kStep1FieldNumber = 4;
  inline ::google::protobuf::uint32 step1() const;
  inline void set_step1(::google::protobuf::uint32 value);
  
  // required uint32 type1 = 5;
  inline bool has_type1() const;
  inline void clear_type1();
  static const int kType1FieldNumber = 5;
  inline ::google::protobuf::uint32 type1() const;
  inline void set_type1(::google::protobuf::uint32 value);
  
  // required bytes imageData1 = 6;
  inline bool has_imagedata1() const;
  inline void clear_imagedata1();
  static const int kImageData1FieldNumber = 6;
  inline const ::std::string& imagedata1() const;
  inline void set_imagedata1(const ::std::string& value);
  inline void set_imagedata1(const char* value);
  inline void set_imagedata1(const void* value, size_t size);
  inline ::std::string* mutable_imagedata1();
  inline ::std::string* release_imagedata1();
  
  // required uint32 step2 = 7;
  inline bool has_step2() const;
  inline void clear_step2();
  static const int kStep2FieldNumber = 7;
  inline ::google::protobuf::uint32 step2() const;
  inline void set_step2(::google::protobuf::uint32 value);
  
  // required uint32 type2 = 8;
  inline bool has_type2() const;
  inline void clear_type2();
  static const int kType2FieldNumber = 8;
  inline ::google::protobuf::uint32 type2() const;
  inline void set_type2(::google::protobuf::uint32 value);
  
  // required bytes imageData2 = 9;
  inline bool has_imagedata2() const;
  inline void clear_imagedata2();
  static const int kImageData2FieldNumber = 9;
  inline const ::std::string& imagedata2() const;
  inline void set_imagedata2(const ::std::string& value);
  inline void set_imagedata2(const char* value);
  inline void set_imagedata2(const void* value, size_t size);
  inline ::std::string* mutable_imagedata2();
  inline ::std::string* release_imagedata2();
  
  // optional uint32 camera_config = 10;
  inline bool has_camera_config() const;
  inline void clear_camera_config();
  static const int kCameraConfigFieldNumber = 10;
  inline ::google::protobuf::uint32 camera_config() const;
  inline void set_camera_config(::google::protobuf::uint32 value);
  
  // optional uint32 camera_type = 11;
  inline bool has_camera_type() const;
  inline void clear_camera_type();
  static const int kCameraTypeFieldNumber = 11;
  inline ::google::protobuf::uint32 camera_type() const;
  inline void set_camera_type(::google::protobuf::uint32 value);
  
  // optional float roll = 12;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 12;
  inline float roll() const;
  inline void set_roll(float value);
  
  // optional float pitch = 13;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 13;
  inline float pitch() const;
  inline void set_pitch(float value);
  
  // optional float yaw = 14;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 14;
  inline float yaw() const;
  inline void set_yaw(float value);
  
  // optional float lon = 15;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 15;
  inline float lon() const;
  inline void set_lon(float value);
  
  // optional float lat = 16;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 16;
  inline float lat() const;
  inline void set_lat(float value);
  
  // optional float alt = 17;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 17;
  inline float alt() const;
  inline void set_alt(float value);
  
  // optional float ground_x = 18;
  inline bool has_ground_x() const;
  inline void clear_ground_x();
  static const int kGroundXFieldNumber = 18;
  inline float ground_x() const;
  inline void set_ground_x(float value);
  
  // optional float ground_y = 19;
  inline bool has_ground_y() const;
  inline void clear_ground_y();
  static const int kGroundYFieldNumber = 19;
  inline float ground_y() const;
  inline void set_ground_y(float value);
  
  // optional float ground_z = 20;
  inline bool has_ground_z() const;
  inline void clear_ground_z();
  static const int kGroundZFieldNumber = 20;
  inline float ground_z() const;
  inline void set_ground_z(float value);
  
  // repeated float camera_matrix = 21;
  inline int camera_matrix_size() const;
  inline void clear_camera_matrix();
  static const int kCameraMatrixFieldNumber = 21;
  inline float camera_matrix(int index) const;
  inline void set_camera_matrix(int index, float value);
  inline void add_camera_matrix(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      camera_matrix() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_camera_matrix();
  
  // @@protoc_insertion_point(class_scope:px.RGBDImage)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_cols();
  inline void clear_has_cols();
  inline void set_has_rows();
  inline void clear_has_rows();
  inline void set_has_step1();
  inline void clear_has_step1();
  inline void set_has_type1();
  inline void clear_has_type1();
  inline void set_has_imagedata1();
  inline void clear_has_imagedata1();
  inline void set_has_step2();
  inline void clear_has_step2();
  inline void set_has_type2();
  inline void clear_has_type2();
  inline void set_has_imagedata2();
  inline void clear_has_imagedata2();
  inline void set_has_camera_config();
  inline void clear_has_camera_config();
  inline void set_has_camera_type();
  inline void clear_has_camera_type();
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_yaw();
  inline void clear_has_yaw();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_alt();
  inline void clear_has_alt();
  inline void set_has_ground_x();
  inline void clear_has_ground_x();
  inline void set_has_ground_y();
  inline void clear_has_ground_y();
  inline void set_has_ground_z();
  inline void clear_has_ground_z();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::px::HeaderInfo* header_;
  ::google::protobuf::uint32 cols_;
  ::google::protobuf::uint32 rows_;
  ::google::protobuf::uint32 step1_;
  ::google::protobuf::uint32 type1_;
  ::std::string* imagedata1_;
  ::google::protobuf::uint32 step2_;
  ::google::protobuf::uint32 type2_;
  ::std::string* imagedata2_;
  ::google::protobuf::uint32 camera_config_;
  ::google::protobuf::uint32 camera_type_;
  float roll_;
  float pitch_;
  float yaw_;
  float lon_;
  float lat_;
  float alt_;
  float ground_x_;
  float ground_y_;
  ::google::protobuf::RepeatedField< float > camera_matrix_;
  float ground_z_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static RGBDImage* default_instance_;
};
// -------------------------------------------------------------------

class Waypoint : public ::google::protobuf::Message {
 public:
  Waypoint();
  virtual ~Waypoint();
  
  Waypoint(const Waypoint& from);
  
  inline Waypoint& operator=(const Waypoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Waypoint& default_instance();
  
  void Swap(Waypoint* other);
  
  // implements Message ----------------------------------------------
  
  Waypoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Waypoint& from);
  void MergeFrom(const Waypoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);
  
  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);
  
  // optional double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);
  
  // optional double roll = 4;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 4;
  inline double roll() const;
  inline void set_roll(double value);
  
  // optional double pitch = 5;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 5;
  inline double pitch() const;
  inline void set_pitch(double value);
  
  // optional double yaw = 6;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 6;
  inline double yaw() const;
  inline void set_yaw(double value);
  
  // @@protoc_insertion_point(class_scope:px.Waypoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_yaw();
  inline void clear_has_yaw();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double x_;
  double y_;
  double z_;
  double roll_;
  double pitch_;
  double yaw_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_pixhawk_2eproto();
  friend void protobuf_AssignDesc_pixhawk_2eproto();
  friend void protobuf_ShutdownFile_pixhawk_2eproto();
  
  void InitAsDefaultInstance();
  static Waypoint* default_instance_;
};
// ===================================================================


// ===================================================================

// HeaderInfo

// required int32 source_sysid = 1;
inline bool HeaderInfo::has_source_sysid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeaderInfo::set_has_source_sysid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeaderInfo::clear_has_source_sysid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeaderInfo::clear_source_sysid() {
  source_sysid_ = 0;
  clear_has_source_sysid();
}
inline ::google::protobuf::int32 HeaderInfo::source_sysid() const {
  return source_sysid_;
}
inline void HeaderInfo::set_source_sysid(::google::protobuf::int32 value) {
  set_has_source_sysid();
  source_sysid_ = value;
}

// required int32 source_compid = 2;
inline bool HeaderInfo::has_source_compid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeaderInfo::set_has_source_compid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeaderInfo::clear_has_source_compid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeaderInfo::clear_source_compid() {
  source_compid_ = 0;
  clear_has_source_compid();
}
inline ::google::protobuf::int32 HeaderInfo::source_compid() const {
  return source_compid_;
}
inline void HeaderInfo::set_source_compid(::google::protobuf::int32 value) {
  set_has_source_compid();
  source_compid_ = value;
}

// required double timestamp = 3;
inline bool HeaderInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeaderInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeaderInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeaderInfo::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double HeaderInfo::timestamp() const {
  return timestamp_;
}
inline void HeaderInfo::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// GLOverlay

// required .px.HeaderInfo header = 1;
inline bool GLOverlay::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GLOverlay::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GLOverlay::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GLOverlay::clear_header() {
  if (header_ != NULL) header_->::px::HeaderInfo::Clear();
  clear_has_header();
}
inline const ::px::HeaderInfo& GLOverlay::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::px::HeaderInfo* GLOverlay::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::px::HeaderInfo;
  return header_;
}
inline ::px::HeaderInfo* GLOverlay::release_header() {
  clear_has_header();
  ::px::HeaderInfo* temp = header_;
  header_ = NULL;
  return temp;
}

// optional string name = 2;
inline bool GLOverlay::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GLOverlay::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GLOverlay::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GLOverlay::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GLOverlay::name() const {
  return *name_;
}
inline void GLOverlay::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GLOverlay::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GLOverlay::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLOverlay::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GLOverlay::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .px.GLOverlay.CoordinateFrameType coordinateFrameType = 3;
inline bool GLOverlay::has_coordinateframetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GLOverlay::set_has_coordinateframetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GLOverlay::clear_has_coordinateframetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GLOverlay::clear_coordinateframetype() {
  coordinateframetype_ = 0;
  clear_has_coordinateframetype();
}
inline ::px::GLOverlay_CoordinateFrameType GLOverlay::coordinateframetype() const {
  return static_cast< ::px::GLOverlay_CoordinateFrameType >(coordinateframetype_);
}
inline void GLOverlay::set_coordinateframetype(::px::GLOverlay_CoordinateFrameType value) {
  GOOGLE_DCHECK(::px::GLOverlay_CoordinateFrameType_IsValid(value));
  set_has_coordinateframetype();
  coordinateframetype_ = value;
}

// optional double origin_x = 4;
inline bool GLOverlay::has_origin_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GLOverlay::set_has_origin_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GLOverlay::clear_has_origin_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GLOverlay::clear_origin_x() {
  origin_x_ = 0;
  clear_has_origin_x();
}
inline double GLOverlay::origin_x() const {
  return origin_x_;
}
inline void GLOverlay::set_origin_x(double value) {
  set_has_origin_x();
  origin_x_ = value;
}

// optional double origin_y = 5;
inline bool GLOverlay::has_origin_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GLOverlay::set_has_origin_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GLOverlay::clear_has_origin_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GLOverlay::clear_origin_y() {
  origin_y_ = 0;
  clear_has_origin_y();
}
inline double GLOverlay::origin_y() const {
  return origin_y_;
}
inline void GLOverlay::set_origin_y(double value) {
  set_has_origin_y();
  origin_y_ = value;
}

// optional double origin_z = 6;
inline bool GLOverlay::has_origin_z() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GLOverlay::set_has_origin_z() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GLOverlay::clear_has_origin_z() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GLOverlay::clear_origin_z() {
  origin_z_ = 0;
  clear_has_origin_z();
}
inline double GLOverlay::origin_z() const {
  return origin_z_;
}
inline void GLOverlay::set_origin_z(double value) {
  set_has_origin_z();
  origin_z_ = value;
}

// optional bytes data = 7;
inline bool GLOverlay::has_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GLOverlay::set_has_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GLOverlay::clear_has_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GLOverlay::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& GLOverlay::data() const {
  return *data_;
}
inline void GLOverlay::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void GLOverlay::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void GLOverlay::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GLOverlay::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* GLOverlay::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Obstacle

// optional float x = 1;
inline bool Obstacle::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Obstacle::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Obstacle::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Obstacle::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Obstacle::x() const {
  return x_;
}
inline void Obstacle::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 2;
inline bool Obstacle::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Obstacle::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Obstacle::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Obstacle::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Obstacle::y() const {
  return y_;
}
inline void Obstacle::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional float z = 3;
inline bool Obstacle::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Obstacle::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Obstacle::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Obstacle::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Obstacle::z() const {
  return z_;
}
inline void Obstacle::set_z(float value) {
  set_has_z();
  z_ = value;
}

// optional float length = 4;
inline bool Obstacle::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Obstacle::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Obstacle::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Obstacle::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float Obstacle::length() const {
  return length_;
}
inline void Obstacle::set_length(float value) {
  set_has_length();
  length_ = value;
}

// optional float width = 5;
inline bool Obstacle::has_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Obstacle::set_has_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Obstacle::clear_has_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Obstacle::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float Obstacle::width() const {
  return width_;
}
inline void Obstacle::set_width(float value) {
  set_has_width();
  width_ = value;
}

// optional float height = 6;
inline bool Obstacle::has_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Obstacle::set_has_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Obstacle::clear_has_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Obstacle::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float Obstacle::height() const {
  return height_;
}
inline void Obstacle::set_height(float value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// ObstacleList

// required .px.HeaderInfo header = 1;
inline bool ObstacleList::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObstacleList::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObstacleList::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObstacleList::clear_header() {
  if (header_ != NULL) header_->::px::HeaderInfo::Clear();
  clear_has_header();
}
inline const ::px::HeaderInfo& ObstacleList::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::px::HeaderInfo* ObstacleList::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::px::HeaderInfo;
  return header_;
}
inline ::px::HeaderInfo* ObstacleList::release_header() {
  clear_has_header();
  ::px::HeaderInfo* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .px.Obstacle obstacles = 2;
inline int ObstacleList::obstacles_size() const {
  return obstacles_.size();
}
inline void ObstacleList::clear_obstacles() {
  obstacles_.Clear();
}
inline const ::px::Obstacle& ObstacleList::obstacles(int index) const {
  return obstacles_.Get(index);
}
inline ::px::Obstacle* ObstacleList::mutable_obstacles(int index) {
  return obstacles_.Mutable(index);
}
inline ::px::Obstacle* ObstacleList::add_obstacles() {
  return obstacles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::px::Obstacle >&
ObstacleList::obstacles() const {
  return obstacles_;
}
inline ::google::protobuf::RepeatedPtrField< ::px::Obstacle >*
ObstacleList::mutable_obstacles() {
  return &obstacles_;
}

// -------------------------------------------------------------------

// ObstacleMap

// required .px.HeaderInfo header = 1;
inline bool ObstacleMap::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObstacleMap::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObstacleMap::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObstacleMap::clear_header() {
  if (header_ != NULL) header_->::px::HeaderInfo::Clear();
  clear_has_header();
}
inline const ::px::HeaderInfo& ObstacleMap::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::px::HeaderInfo* ObstacleMap::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::px::HeaderInfo;
  return header_;
}
inline ::px::HeaderInfo* ObstacleMap::release_header() {
  clear_has_header();
  ::px::HeaderInfo* temp = header_;
  header_ = NULL;
  return temp;
}

// required int32 type = 2;
inline bool ObstacleMap::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObstacleMap::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObstacleMap::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObstacleMap::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ObstacleMap::type() const {
  return type_;
}
inline void ObstacleMap::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional float resolution = 3;
inline bool ObstacleMap::has_resolution() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObstacleMap::set_has_resolution() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObstacleMap::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObstacleMap::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline float ObstacleMap::resolution() const {
  return resolution_;
}
inline void ObstacleMap::set_resolution(float value) {
  set_has_resolution();
  resolution_ = value;
}

// optional int32 rows = 4;
inline bool ObstacleMap::has_rows() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObstacleMap::set_has_rows() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObstacleMap::clear_has_rows() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObstacleMap::clear_rows() {
  rows_ = 0;
  clear_has_rows();
}
inline ::google::protobuf::int32 ObstacleMap::rows() const {
  return rows_;
}
inline void ObstacleMap::set_rows(::google::protobuf::int32 value) {
  set_has_rows();
  rows_ = value;
}

// optional int32 cols = 5;
inline bool ObstacleMap::has_cols() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ObstacleMap::set_has_cols() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ObstacleMap::clear_has_cols() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ObstacleMap::clear_cols() {
  cols_ = 0;
  clear_has_cols();
}
inline ::google::protobuf::int32 ObstacleMap::cols() const {
  return cols_;
}
inline void ObstacleMap::set_cols(::google::protobuf::int32 value) {
  set_has_cols();
  cols_ = value;
}

// optional int32 mapR0 = 6;
inline bool ObstacleMap::has_mapr0() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ObstacleMap::set_has_mapr0() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ObstacleMap::clear_has_mapr0() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ObstacleMap::clear_mapr0() {
  mapr0_ = 0;
  clear_has_mapr0();
}
inline ::google::protobuf::int32 ObstacleMap::mapr0() const {
  return mapr0_;
}
inline void ObstacleMap::set_mapr0(::google::protobuf::int32 value) {
  set_has_mapr0();
  mapr0_ = value;
}

// optional int32 mapC0 = 7;
inline bool ObstacleMap::has_mapc0() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ObstacleMap::set_has_mapc0() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ObstacleMap::clear_has_mapc0() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ObstacleMap::clear_mapc0() {
  mapc0_ = 0;
  clear_has_mapc0();
}
inline ::google::protobuf::int32 ObstacleMap::mapc0() const {
  return mapc0_;
}
inline void ObstacleMap::set_mapc0(::google::protobuf::int32 value) {
  set_has_mapc0();
  mapc0_ = value;
}

// optional int32 arrayR0 = 8;
inline bool ObstacleMap::has_arrayr0() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ObstacleMap::set_has_arrayr0() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ObstacleMap::clear_has_arrayr0() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ObstacleMap::clear_arrayr0() {
  arrayr0_ = 0;
  clear_has_arrayr0();
}
inline ::google::protobuf::int32 ObstacleMap::arrayr0() const {
  return arrayr0_;
}
inline void ObstacleMap::set_arrayr0(::google::protobuf::int32 value) {
  set_has_arrayr0();
  arrayr0_ = value;
}

// optional int32 arrayC0 = 9;
inline bool ObstacleMap::has_arrayc0() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ObstacleMap::set_has_arrayc0() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ObstacleMap::clear_has_arrayc0() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ObstacleMap::clear_arrayc0() {
  arrayc0_ = 0;
  clear_has_arrayc0();
}
inline ::google::protobuf::int32 ObstacleMap::arrayc0() const {
  return arrayc0_;
}
inline void ObstacleMap::set_arrayc0(::google::protobuf::int32 value) {
  set_has_arrayc0();
  arrayc0_ = value;
}

// optional bytes data = 10;
inline bool ObstacleMap::has_data() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ObstacleMap::set_has_data() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ObstacleMap::clear_has_data() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ObstacleMap::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ObstacleMap::data() const {
  return *data_;
}
inline void ObstacleMap::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ObstacleMap::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ObstacleMap::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObstacleMap::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ObstacleMap::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Path

// required .px.HeaderInfo header = 1;
inline bool Path::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Path::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Path::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Path::clear_header() {
  if (header_ != NULL) header_->::px::HeaderInfo::Clear();
  clear_has_header();
}
inline const ::px::HeaderInfo& Path::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::px::HeaderInfo* Path::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::px::HeaderInfo;
  return header_;
}
inline ::px::HeaderInfo* Path::release_header() {
  clear_has_header();
  ::px::HeaderInfo* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .px.Waypoint waypoints = 2;
inline int Path::waypoints_size() const {
  return waypoints_.size();
}
inline void Path::clear_waypoints() {
  waypoints_.Clear();
}
inline const ::px::Waypoint& Path::waypoints(int index) const {
  return waypoints_.Get(index);
}
inline ::px::Waypoint* Path::mutable_waypoints(int index) {
  return waypoints_.Mutable(index);
}
inline ::px::Waypoint* Path::add_waypoints() {
  return waypoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::px::Waypoint >&
Path::waypoints() const {
  return waypoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::px::Waypoint >*
Path::mutable_waypoints() {
  return &waypoints_;
}

// -------------------------------------------------------------------

// PointCloudXYZI_PointXYZI

// required float x = 1;
inline bool PointCloudXYZI_PointXYZI::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointCloudXYZI_PointXYZI::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointCloudXYZI_PointXYZI::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointCloudXYZI_PointXYZI::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float PointCloudXYZI_PointXYZI::x() const {
  return x_;
}
inline void PointCloudXYZI_PointXYZI::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool PointCloudXYZI_PointXYZI::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointCloudXYZI_PointXYZI::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointCloudXYZI_PointXYZI::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointCloudXYZI_PointXYZI::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float PointCloudXYZI_PointXYZI::y() const {
  return y_;
}
inline void PointCloudXYZI_PointXYZI::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool PointCloudXYZI_PointXYZI::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointCloudXYZI_PointXYZI::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointCloudXYZI_PointXYZI::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointCloudXYZI_PointXYZI::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float PointCloudXYZI_PointXYZI::z() const {
  return z_;
}
inline void PointCloudXYZI_PointXYZI::set_z(float value) {
  set_has_z();
  z_ = value;
}

// required float intensity = 4;
inline bool PointCloudXYZI_PointXYZI::has_intensity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PointCloudXYZI_PointXYZI::set_has_intensity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PointCloudXYZI_PointXYZI::clear_has_intensity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PointCloudXYZI_PointXYZI::clear_intensity() {
  intensity_ = 0;
  clear_has_intensity();
}
inline float PointCloudXYZI_PointXYZI::intensity() const {
  return intensity_;
}
inline void PointCloudXYZI_PointXYZI::set_intensity(float value) {
  set_has_intensity();
  intensity_ = value;
}

// -------------------------------------------------------------------

// PointCloudXYZI

// required .px.HeaderInfo header = 1;
inline bool PointCloudXYZI::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointCloudXYZI::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointCloudXYZI::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointCloudXYZI::clear_header() {
  if (header_ != NULL) header_->::px::HeaderInfo::Clear();
  clear_has_header();
}
inline const ::px::HeaderInfo& PointCloudXYZI::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::px::HeaderInfo* PointCloudXYZI::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::px::HeaderInfo;
  return header_;
}
inline ::px::HeaderInfo* PointCloudXYZI::release_header() {
  clear_has_header();
  ::px::HeaderInfo* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .px.PointCloudXYZI.PointXYZI points = 2;
inline int PointCloudXYZI::points_size() const {
  return points_.size();
}
inline void PointCloudXYZI::clear_points() {
  points_.Clear();
}
inline const ::px::PointCloudXYZI_PointXYZI& PointCloudXYZI::points(int index) const {
  return points_.Get(index);
}
inline ::px::PointCloudXYZI_PointXYZI* PointCloudXYZI::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::px::PointCloudXYZI_PointXYZI* PointCloudXYZI::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZI_PointXYZI >&
PointCloudXYZI::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZI_PointXYZI >*
PointCloudXYZI::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// PointCloudXYZRGB_PointXYZRGB

// required float x = 1;
inline bool PointCloudXYZRGB_PointXYZRGB::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float PointCloudXYZRGB_PointXYZRGB::x() const {
  return x_;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool PointCloudXYZRGB_PointXYZRGB::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float PointCloudXYZRGB_PointXYZRGB::y() const {
  return y_;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool PointCloudXYZRGB_PointXYZRGB::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float PointCloudXYZRGB_PointXYZRGB::z() const {
  return z_;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_z(float value) {
  set_has_z();
  z_ = value;
}

// required float rgb = 4;
inline bool PointCloudXYZRGB_PointXYZRGB::has_rgb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_has_rgb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_has_rgb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PointCloudXYZRGB_PointXYZRGB::clear_rgb() {
  rgb_ = 0;
  clear_has_rgb();
}
inline float PointCloudXYZRGB_PointXYZRGB::rgb() const {
  return rgb_;
}
inline void PointCloudXYZRGB_PointXYZRGB::set_rgb(float value) {
  set_has_rgb();
  rgb_ = value;
}

// -------------------------------------------------------------------

// PointCloudXYZRGB

// required .px.HeaderInfo header = 1;
inline bool PointCloudXYZRGB::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointCloudXYZRGB::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointCloudXYZRGB::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointCloudXYZRGB::clear_header() {
  if (header_ != NULL) header_->::px::HeaderInfo::Clear();
  clear_has_header();
}
inline const ::px::HeaderInfo& PointCloudXYZRGB::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::px::HeaderInfo* PointCloudXYZRGB::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::px::HeaderInfo;
  return header_;
}
inline ::px::HeaderInfo* PointCloudXYZRGB::release_header() {
  clear_has_header();
  ::px::HeaderInfo* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .px.PointCloudXYZRGB.PointXYZRGB points = 2;
inline int PointCloudXYZRGB::points_size() const {
  return points_.size();
}
inline void PointCloudXYZRGB::clear_points() {
  points_.Clear();
}
inline const ::px::PointCloudXYZRGB_PointXYZRGB& PointCloudXYZRGB::points(int index) const {
  return points_.Get(index);
}
inline ::px::PointCloudXYZRGB_PointXYZRGB* PointCloudXYZRGB::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::px::PointCloudXYZRGB_PointXYZRGB* PointCloudXYZRGB::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZRGB_PointXYZRGB >&
PointCloudXYZRGB::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::px::PointCloudXYZRGB_PointXYZRGB >*
PointCloudXYZRGB::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// RGBDImage

// required .px.HeaderInfo header = 1;
inline bool RGBDImage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RGBDImage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RGBDImage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RGBDImage::clear_header() {
  if (header_ != NULL) header_->::px::HeaderInfo::Clear();
  clear_has_header();
}
inline const ::px::HeaderInfo& RGBDImage::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::px::HeaderInfo* RGBDImage::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::px::HeaderInfo;
  return header_;
}
inline ::px::HeaderInfo* RGBDImage::release_header() {
  clear_has_header();
  ::px::HeaderInfo* temp = header_;
  header_ = NULL;
  return temp;
}

// required uint32 cols = 2;
inline bool RGBDImage::has_cols() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RGBDImage::set_has_cols() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RGBDImage::clear_has_cols() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RGBDImage::clear_cols() {
  cols_ = 0u;
  clear_has_cols();
}
inline ::google::protobuf::uint32 RGBDImage::cols() const {
  return cols_;
}
inline void RGBDImage::set_cols(::google::protobuf::uint32 value) {
  set_has_cols();
  cols_ = value;
}

// required uint32 rows = 3;
inline bool RGBDImage::has_rows() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RGBDImage::set_has_rows() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RGBDImage::clear_has_rows() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RGBDImage::clear_rows() {
  rows_ = 0u;
  clear_has_rows();
}
inline ::google::protobuf::uint32 RGBDImage::rows() const {
  return rows_;
}
inline void RGBDImage::set_rows(::google::protobuf::uint32 value) {
  set_has_rows();
  rows_ = value;
}

// required uint32 step1 = 4;
inline bool RGBDImage::has_step1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RGBDImage::set_has_step1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RGBDImage::clear_has_step1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RGBDImage::clear_step1() {
  step1_ = 0u;
  clear_has_step1();
}
inline ::google::protobuf::uint32 RGBDImage::step1() const {
  return step1_;
}
inline void RGBDImage::set_step1(::google::protobuf::uint32 value) {
  set_has_step1();
  step1_ = value;
}

// required uint32 type1 = 5;
inline bool RGBDImage::has_type1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RGBDImage::set_has_type1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RGBDImage::clear_has_type1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RGBDImage::clear_type1() {
  type1_ = 0u;
  clear_has_type1();
}
inline ::google::protobuf::uint32 RGBDImage::type1() const {
  return type1_;
}
inline void RGBDImage::set_type1(::google::protobuf::uint32 value) {
  set_has_type1();
  type1_ = value;
}

// required bytes imageData1 = 6;
inline bool RGBDImage::has_imagedata1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RGBDImage::set_has_imagedata1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RGBDImage::clear_has_imagedata1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RGBDImage::clear_imagedata1() {
  if (imagedata1_ != &::google::protobuf::internal::kEmptyString) {
    imagedata1_->clear();
  }
  clear_has_imagedata1();
}
inline const ::std::string& RGBDImage::imagedata1() const {
  return *imagedata1_;
}
inline void RGBDImage::set_imagedata1(const ::std::string& value) {
  set_has_imagedata1();
  if (imagedata1_ == &::google::protobuf::internal::kEmptyString) {
    imagedata1_ = new ::std::string;
  }
  imagedata1_->assign(value);
}
inline void RGBDImage::set_imagedata1(const char* value) {
  set_has_imagedata1();
  if (imagedata1_ == &::google::protobuf::internal::kEmptyString) {
    imagedata1_ = new ::std::string;
  }
  imagedata1_->assign(value);
}
inline void RGBDImage::set_imagedata1(const void* value, size_t size) {
  set_has_imagedata1();
  if (imagedata1_ == &::google::protobuf::internal::kEmptyString) {
    imagedata1_ = new ::std::string;
  }
  imagedata1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RGBDImage::mutable_imagedata1() {
  set_has_imagedata1();
  if (imagedata1_ == &::google::protobuf::internal::kEmptyString) {
    imagedata1_ = new ::std::string;
  }
  return imagedata1_;
}
inline ::std::string* RGBDImage::release_imagedata1() {
  clear_has_imagedata1();
  if (imagedata1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imagedata1_;
    imagedata1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 step2 = 7;
inline bool RGBDImage::has_step2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RGBDImage::set_has_step2() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RGBDImage::clear_has_step2() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RGBDImage::clear_step2() {
  step2_ = 0u;
  clear_has_step2();
}
inline ::google::protobuf::uint32 RGBDImage::step2() const {
  return step2_;
}
inline void RGBDImage::set_step2(::google::protobuf::uint32 value) {
  set_has_step2();
  step2_ = value;
}

// required uint32 type2 = 8;
inline bool RGBDImage::has_type2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RGBDImage::set_has_type2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RGBDImage::clear_has_type2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RGBDImage::clear_type2() {
  type2_ = 0u;
  clear_has_type2();
}
inline ::google::protobuf::uint32 RGBDImage::type2() const {
  return type2_;
}
inline void RGBDImage::set_type2(::google::protobuf::uint32 value) {
  set_has_type2();
  type2_ = value;
}

// required bytes imageData2 = 9;
inline bool RGBDImage::has_imagedata2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RGBDImage::set_has_imagedata2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RGBDImage::clear_has_imagedata2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RGBDImage::clear_imagedata2() {
  if (imagedata2_ != &::google::protobuf::internal::kEmptyString) {
    imagedata2_->clear();
  }
  clear_has_imagedata2();
}
inline const ::std::string& RGBDImage::imagedata2() const {
  return *imagedata2_;
}
inline void RGBDImage::set_imagedata2(const ::std::string& value) {
  set_has_imagedata2();
  if (imagedata2_ == &::google::protobuf::internal::kEmptyString) {
    imagedata2_ = new ::std::string;
  }
  imagedata2_->assign(value);
}
inline void RGBDImage::set_imagedata2(const char* value) {
  set_has_imagedata2();
  if (imagedata2_ == &::google::protobuf::internal::kEmptyString) {
    imagedata2_ = new ::std::string;
  }
  imagedata2_->assign(value);
}
inline void RGBDImage::set_imagedata2(const void* value, size_t size) {
  set_has_imagedata2();
  if (imagedata2_ == &::google::protobuf::internal::kEmptyString) {
    imagedata2_ = new ::std::string;
  }
  imagedata2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RGBDImage::mutable_imagedata2() {
  set_has_imagedata2();
  if (imagedata2_ == &::google::protobuf::internal::kEmptyString) {
    imagedata2_ = new ::std::string;
  }
  return imagedata2_;
}
inline ::std::string* RGBDImage::release_imagedata2() {
  clear_has_imagedata2();
  if (imagedata2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imagedata2_;
    imagedata2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 camera_config = 10;
inline bool RGBDImage::has_camera_config() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RGBDImage::set_has_camera_config() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RGBDImage::clear_has_camera_config() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RGBDImage::clear_camera_config() {
  camera_config_ = 0u;
  clear_has_camera_config();
}
inline ::google::protobuf::uint32 RGBDImage::camera_config() const {
  return camera_config_;
}
inline void RGBDImage::set_camera_config(::google::protobuf::uint32 value) {
  set_has_camera_config();
  camera_config_ = value;
}

// optional uint32 camera_type = 11;
inline bool RGBDImage::has_camera_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RGBDImage::set_has_camera_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RGBDImage::clear_has_camera_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RGBDImage::clear_camera_type() {
  camera_type_ = 0u;
  clear_has_camera_type();
}
inline ::google::protobuf::uint32 RGBDImage::camera_type() const {
  return camera_type_;
}
inline void RGBDImage::set_camera_type(::google::protobuf::uint32 value) {
  set_has_camera_type();
  camera_type_ = value;
}

// optional float roll = 12;
inline bool RGBDImage::has_roll() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RGBDImage::set_has_roll() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RGBDImage::clear_has_roll() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RGBDImage::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float RGBDImage::roll() const {
  return roll_;
}
inline void RGBDImage::set_roll(float value) {
  set_has_roll();
  roll_ = value;
}

// optional float pitch = 13;
inline bool RGBDImage::has_pitch() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RGBDImage::set_has_pitch() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RGBDImage::clear_has_pitch() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RGBDImage::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float RGBDImage::pitch() const {
  return pitch_;
}
inline void RGBDImage::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
}

// optional float yaw = 14;
inline bool RGBDImage::has_yaw() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RGBDImage::set_has_yaw() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RGBDImage::clear_has_yaw() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RGBDImage::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float RGBDImage::yaw() const {
  return yaw_;
}
inline void RGBDImage::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
}

// optional float lon = 15;
inline bool RGBDImage::has_lon() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RGBDImage::set_has_lon() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RGBDImage::clear_has_lon() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RGBDImage::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float RGBDImage::lon() const {
  return lon_;
}
inline void RGBDImage::set_lon(float value) {
  set_has_lon();
  lon_ = value;
}

// optional float lat = 16;
inline bool RGBDImage::has_lat() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RGBDImage::set_has_lat() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RGBDImage::clear_has_lat() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RGBDImage::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float RGBDImage::lat() const {
  return lat_;
}
inline void RGBDImage::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float alt = 17;
inline bool RGBDImage::has_alt() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RGBDImage::set_has_alt() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RGBDImage::clear_has_alt() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RGBDImage::clear_alt() {
  alt_ = 0;
  clear_has_alt();
}
inline float RGBDImage::alt() const {
  return alt_;
}
inline void RGBDImage::set_alt(float value) {
  set_has_alt();
  alt_ = value;
}

// optional float ground_x = 18;
inline bool RGBDImage::has_ground_x() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RGBDImage::set_has_ground_x() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RGBDImage::clear_has_ground_x() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RGBDImage::clear_ground_x() {
  ground_x_ = 0;
  clear_has_ground_x();
}
inline float RGBDImage::ground_x() const {
  return ground_x_;
}
inline void RGBDImage::set_ground_x(float value) {
  set_has_ground_x();
  ground_x_ = value;
}

// optional float ground_y = 19;
inline bool RGBDImage::has_ground_y() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RGBDImage::set_has_ground_y() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RGBDImage::clear_has_ground_y() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RGBDImage::clear_ground_y() {
  ground_y_ = 0;
  clear_has_ground_y();
}
inline float RGBDImage::ground_y() const {
  return ground_y_;
}
inline void RGBDImage::set_ground_y(float value) {
  set_has_ground_y();
  ground_y_ = value;
}

// optional float ground_z = 20;
inline bool RGBDImage::has_ground_z() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RGBDImage::set_has_ground_z() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RGBDImage::clear_has_ground_z() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RGBDImage::clear_ground_z() {
  ground_z_ = 0;
  clear_has_ground_z();
}
inline float RGBDImage::ground_z() const {
  return ground_z_;
}
inline void RGBDImage::set_ground_z(float value) {
  set_has_ground_z();
  ground_z_ = value;
}

// repeated float camera_matrix = 21;
inline int RGBDImage::camera_matrix_size() const {
  return camera_matrix_.size();
}
inline void RGBDImage::clear_camera_matrix() {
  camera_matrix_.Clear();
}
inline float RGBDImage::camera_matrix(int index) const {
  return camera_matrix_.Get(index);
}
inline void RGBDImage::set_camera_matrix(int index, float value) {
  camera_matrix_.Set(index, value);
}
inline void RGBDImage::add_camera_matrix(float value) {
  camera_matrix_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RGBDImage::camera_matrix() const {
  return camera_matrix_;
}
inline ::google::protobuf::RepeatedField< float >*
RGBDImage::mutable_camera_matrix() {
  return &camera_matrix_;
}

// -------------------------------------------------------------------

// Waypoint

// required double x = 1;
inline bool Waypoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Waypoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Waypoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Waypoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Waypoint::x() const {
  return x_;
}
inline void Waypoint::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool Waypoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Waypoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Waypoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Waypoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Waypoint::y() const {
  return y_;
}
inline void Waypoint::set_y(double value) {
  set_has_y();
  y_ = value;
}

// optional double z = 3;
inline bool Waypoint::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Waypoint::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Waypoint::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Waypoint::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Waypoint::z() const {
  return z_;
}
inline void Waypoint::set_z(double value) {
  set_has_z();
  z_ = value;
}

// optional double roll = 4;
inline bool Waypoint::has_roll() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Waypoint::set_has_roll() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Waypoint::clear_has_roll() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Waypoint::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline double Waypoint::roll() const {
  return roll_;
}
inline void Waypoint::set_roll(double value) {
  set_has_roll();
  roll_ = value;
}

// optional double pitch = 5;
inline bool Waypoint::has_pitch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Waypoint::set_has_pitch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Waypoint::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Waypoint::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline double Waypoint::pitch() const {
  return pitch_;
}
inline void Waypoint::set_pitch(double value) {
  set_has_pitch();
  pitch_ = value;
}

// optional double yaw = 6;
inline bool Waypoint::has_yaw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Waypoint::set_has_yaw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Waypoint::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Waypoint::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline double Waypoint::yaw() const {
  return yaw_;
}
inline void Waypoint::set_yaw(double value) {
  set_has_yaw();
  yaw_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace px

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::px::GLOverlay_CoordinateFrameType>() {
  return ::px::GLOverlay_CoordinateFrameType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::px::GLOverlay_Mode>() {
  return ::px::GLOverlay_Mode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::px::GLOverlay_Identifier>() {
  return ::px::GLOverlay_Identifier_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pixhawk_2eproto__INCLUDED
